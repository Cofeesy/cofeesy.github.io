<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon-16x16-next.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon-16x16-next.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-08-25T09:22:57.000Z" title="8/25/2025, 5:22:57 PM">2025-08-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-25T09:23:21.238Z" title="8/25/2025, 5:23:21 PM">2025-08-25</time></span><span class="level-item">13 minutes read (About 1928 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/08/25/%E5%88%9D%E5%AD%A6flag%E5%8C%85/">初学flag包</a></p><div class="content"><p><code>flag</code> 包是 Go 语言标准库中处理命令行参数的利器。学会它，你就能轻松地为你编写的命令行工具添加 <code>-h</code>、<code>-version</code> 等专业的参数功能。</p>
<hr>
<h3 id="第一阶段：理解核心思想-——-什么是命令行标志-Flag-？"><a href="#第一阶段：理解核心思想-——-什么是命令行标志-Flag-？" class="headerlink" title="第一阶段：理解核心思想 —— 什么是命令行标志 (Flag)？"></a>第一阶段：理解核心思想 —— 什么是命令行标志 (Flag)？</h3><p>在学习代码之前，先理解概念。命令行标志（Flag）是程序运行时，在程序名后面跟的一些**“键值对”<strong>或</strong>“开关”**，用来改变程序的行为。</p>
<p>看一个我们熟悉的命令 <code>ls</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l -h /home/user</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ls</code>: 是程序名。</li>
<li><code>-l</code>: 是一个<strong>布尔型 (bool) 标志</strong>。它就像一个开关，打开了“长列表格式”显示。</li>
<li><code>-h</code>: 也是一个布尔型标志，打开了“人类可读的文件大小”显示。</li>
<li><code>/home/user</code>: 这个不是标志，它是一个普通的<strong>命令行参数 (argument)</strong>。</li>
</ul>
<p><code>flag</code> 包就是专门用来定义和解析 <code>-l</code> 和 <code>-h</code> 这种<strong>带 <code>-</code> 或 <code>--</code> 前缀</strong>的标志的。</p>
<p><strong>核心思想</strong>：</p>
<ol>
<li><strong>定义 (Define)</strong>：在程序里预先声明你的程序接受哪些标志，它们是什么类型（字符串、整数、布尔值），以及它们的默认值和说明。</li>
<li><strong>解析 (Parse)</strong>：在程序开始运行时，调用一个函数来解析用户在命令行实际传入了哪些标志和值。</li>
<li><strong>使用 (Use)</strong>：在程序的后续逻辑中，像使用普通变量一样使用这些被解析出来的值。</li>
</ol>
<hr>
<h3 id="第二阶段：掌握两种定义标志的方法"><a href="#第二阶段：掌握两种定义标志的方法" class="headerlink" title="第二阶段：掌握两种定义标志的方法"></a>第二阶段：掌握两种定义标志的方法</h3><p><code>flag</code> 包提供了两种风格的定义方式，你需要都了解。</p>
<h4 id="方法一：flag-String-flag-Int-flag-Bool-等系列函数"><a href="#方法一：flag-String-flag-Int-flag-Bool-等系列函数" class="headerlink" title="方法一：flag.String(), flag.Int(), flag.Bool() 等系列函数"></a>方法一：<code>flag.String()</code>, <code>flag.Int()</code>, <code>flag.Bool()</code> 等系列函数</h4><p>这种方法最常用，也最直接。它会返回一个<strong>指向解析值的指针</strong>。</p>
<p><strong>函数签名格式</strong>:<br><code>flag.Type(name string, defaultValue Type, usage string) *Type</code></p>
<ul>
<li><code>name</code>: 标志的名字 (例如: “port”)。</li>
<li><code>defaultValue</code>: 如果用户不提供这个标志，它会有的默认值。</li>
<li><code>usage</code>: 标志的说明文字，当用户使用 <code>-h</code> 或 <code>-help</code> 时会显示。</li>
<li>返回值: 一个指向该类型值的<strong>指针</strong>。</li>
</ul>
<p><strong>实战代码 1</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 定义标志</span></span><br><span class="line">	<span class="comment">// 定义一个名为 &quot;port&quot;，默认值为 8080 的整数标志</span></span><br><span class="line">	portPtr := flag.Int(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;设置服务监听的端口&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个名为 &quot;host&quot;，默认值为 &quot;localhost&quot; 的字符串标志</span></span><br><span class="line">	hostPtr := flag.String(<span class="string">&quot;host&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;设置服务监听的主机名&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个名为 &quot;debug&quot;，默认值为 false 的布尔标志</span></span><br><span class="line">	<span class="comment">// 布尔标志有两种用法: -debug 或者 -debug=true</span></span><br><span class="line">	debugPtr := flag.Bool(<span class="string">&quot;debug&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;开启调试模式&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 解析标志</span></span><br><span class="line">	<span class="comment">// 这一步至关重要！它会真正去读取 os.Args 来填充上面定义的指针</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 使用标志</span></span><br><span class="line">	<span class="comment">// 因为返回的是指针，所以需要使用 * 来获取值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;服务将运行在: %s:%d\n&quot;</span>, *hostPtr, *portPtr)</span><br><span class="line">	<span class="keyword">if</span> *debugPtr &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;调试模式已开启！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flag.Args() 可以获取非标志的普通参数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;剩余的普通参数:&quot;</span>, flag.Args())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何运行和测试这段代码</strong>:</p>
<ol>
<li><code>go build -o myapp</code></li>
<li>不带任何标志运行: <code>./myapp</code> -&gt; 使用所有默认值。</li>
<li>提供标志: <code>./myapp -port=9090 -host=0.0.0.0 -debug</code></li>
<li>提供布尔标志的另一种方式: <code>./myapp -debug=true</code></li>
<li>查看帮助信息: <code>./myapp -h</code> 或 <code>./myapp --help</code>，你会看到你写的 <code>usage</code> 信息。</li>
<li>提供普通参数: <code>./myapp -port=3000 arg1 arg2</code></li>
</ol>
<h4 id="方法二：flag-StringVar-flag-IntVar-flag-BoolVar-等系列函数"><a href="#方法二：flag-StringVar-flag-IntVar-flag-BoolVar-等系列函数" class="headerlink" title="方法二：flag.StringVar(), flag.IntVar(), flag.BoolVar() 等系列函数"></a>方法二：<code>flag.StringVar()</code>, <code>flag.IntVar()</code>, <code>flag.BoolVar()</code> 等系列函数</h4><p>这种方法允许你将解析的值<strong>绑定到一个已经存在的变量</strong>上。这在变量需要被多个函数共享时可能更方便。</p>
<p><strong>函数签名格式</strong>:<br><code>flag.TypeVar(p *Type, name string, defaultValue Type, usage string)</code></p>
<ul>
<li><code>p</code>: 一个指向你提前定义好的变量的<strong>指针</strong>。</li>
<li>其他参数和方法一相同。</li>
<li>这个系列函数没有返回值。</li>
</ul>
<p><strong>实战代码 2 (功能同上)</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前定义好变量</span></span><br><span class="line"><span class="keyword">var</span> port <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> host <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> debug <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 定义标志并绑定到已有变量</span></span><br><span class="line">	<span class="comment">// 注意第一个参数是变量的地址 (&amp;port)</span></span><br><span class="line">	flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;设置服务监听的端口&quot;</span>)</span><br><span class="line">	flag.StringVar(&amp;host, <span class="string">&quot;host&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;设置服务监听的主机名&quot;</span>)</span><br><span class="line">	flag.BoolVar(&amp;debug, <span class="string">&quot;debug&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;开启调试模式&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 解析标志</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 使用标志</span></span><br><span class="line">	<span class="comment">// 因为值是直接绑定到变量上的，所以直接使用变量名即可，无需 *</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;服务将运行在: %s:%d\n&quot;</span>, host, port)</span><br><span class="line">	<span class="keyword">if</span> debug &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;调试模式已开启！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比两种方法</strong>:</p>
<ul>
<li>方法一（返回指针）更紧凑，定义和获取都在一个地方。</li>
<li>方法二（绑定变量）在变量需要是全局或在多个地方访问时，代码结构可能更清晰。</li>
<li>选择哪种主要看个人编码风格和具体场景，功能上没有优劣之分。初学者可以先熟练掌握第一种。</li>
</ul>
<hr>
<h3 id="第三阶段：学习高级用法和最佳实践"><a href="#第三阶段：学习高级用法和最佳实践" class="headerlink" title="第三阶段：学习高级用法和最佳实践"></a>第三阶段：学习高级用法和最佳实践</h3><ol>
<li><p><strong>自定义标志类型</strong>: <code>flag.Var()</code></p>
<ul>
<li>有时你需要处理更复杂的类型，比如一个逗号分隔的列表。你可以通过实现 <code>flag.Value</code> 接口来自定义标志类型。这是一个进阶话题，初学时可以先了解。</li>
</ul>
</li>
<li><p><strong><code>flag.Args()</code> 和 <code>flag.NArg()</code></strong></p>
<ul>
<li><code>flag.Args()</code>: 返回一个字符串切片 <code>[]string</code>，包含所有<strong>非标志</strong>的命令行参数（就是那些前面没有 <code>-</code> 的参数）。</li>
<li><code>flag.NArg()</code>: 返回非标志参数的数量，等同于 <code>len(flag.Args())</code>。</li>
</ul>
</li>
<li><p><strong>改变默认的帮助信息</strong>: <code>flag.Usage</code></p>
<ul>
<li><code>flag.Usage</code> 是一个变量，它的类型是 <code>func()</code>。你可以将它赋值为你自己的函数，来自定义 <code>-h</code> 时显示的帮助信息，比如加上程序的使用示例。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">&quot;用法: %s [选项] &lt;参数1&gt; &lt;参数2&gt;\n&quot;</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">    fmt.Fprintln(os.Stderr, <span class="string">&quot;选项:&quot;</span>)</span><br><span class="line">    flag.PrintDefaults() <span class="comment">// 打印所有已定义的标志的默认说明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>flag.Parse()</code> 的位置</strong></p>
<ul>
<li><code>flag.Parse()</code> <strong>必须在所有标志都定义完成之后，并且在第一次使用任何标志的值之前</strong>被调用。通常把它放在 <code>main</code> 函数的开头部分。</li>
</ul>
</li>
<li><p><strong>FlagSet</strong>: 创建独立的标志集</p>
<ul>
<li>默认情况下，所有的 <code>flag.String</code>, <code>flag.Int</code> 等函数都操作一个全局的标志集 <code>flag.CommandLine</code>。</li>
<li>如果你在编写一个复杂的程序，有多个子命令（比如 <code>git commit</code>, <code>git push</code>），每个子命令有自己不同的标志，这时你可以使用 <code>flag.NewFlagSet</code> 来为每个子命令创建独立的标志集。这是构建复杂命令行工具的关键。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="学习路径总结"><a href="#学习路径总结" class="headerlink" title="学习路径总结"></a>学习路径总结</h3><ol>
<li><strong>理解目的</strong>: <code>flag</code> 包是用来处理 <code>-name=value</code> 形式的命令行标志的。</li>
<li><strong>掌握基础</strong>: 熟练使用 <code>flag.String()</code>, <code>flag.Int()</code>, <code>flag.Bool()</code> 这三个函数。记住定义、解析、使用的三步流程。</li>
<li><strong>动手实践</strong>: 编写一个小工具，用 <code>flag</code> 添加配置项，并通过命令行改变它的行为。</li>
<li><strong>了解进阶</strong>: 知道 <code>flag.Args()</code> 是用来获取非标志参数的，以及 <code>flag.Usage</code> 可以自定义帮助信息。</li>
<li><strong>展望未来</strong>: 当你需要构建类似 <code>docker</code> 或 <code>kubectl</code> 这样的多子命令工具时，再去深入研究 <code>FlagSet</code>。</li>
</ol>
<p>通过这个路径，你就能扎实地掌握 <code>flag</code> 包，并为你未来的 Go 程序编写出专业、易用的命令行接口。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-08-25T08:42:09.000Z" title="8/25/2025, 4:42:09 PM">2025-08-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-25T09:05:27.786Z" title="8/25/2025, 5:05:27 PM">2025-08-25</time></span><span class="level-item">28 minutes read (About 4221 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/08/25/%E5%88%9D%E5%AD%A6bufio%E5%8C%85/">初学bufio包</a></p><div class="content"><h3 id="第一阶段：理解核心思想-——-为什么要用-bufio？"><a href="#第一阶段：理解核心思想-——-为什么要用-bufio？" class="headerlink" title="第一阶段：理解核心思想 —— 为什么要用 bufio？"></a>第一阶段：理解核心思想 —— 为什么要用 <code>bufio</code>？</h3><p>在直接看代码之前，你必须先理解 <code>bufio</code> 存在的<strong>根本原因</strong>：<strong>减少系统调用，提升 I&#x2F;O 性能</strong>。</p>
<p>想象一下你要从超市（磁盘）买100件商品（数据）。你有两种方式：</p>
<ol>
<li><strong>不用 <code>bufio</code></strong>: 每次只拿一件商品，然后去收银台结账，来回100次。结账这个动作就像一次“系统调用（System Call）”，非常耗时。</li>
<li><strong>使用 <code>bufio</code></strong>: 你推一个购物车（<strong>缓冲区 Buffer</strong>），先把100件商品都放进购物车里，最后<strong>只去收银台结账一次</strong>。</li>
</ol>
<p><code>bufio</code> 包就是这个“购物车”。它在内存中开辟一块缓冲区，当你读取数据时，它会一次性从磁盘（或网络）读取一大块数据到缓冲区；当你写入数据时，它会先把数据写入缓冲区，等缓冲区满了或者你主动要求时，才一次性写入磁盘。</p>
<p><strong>核心结论</strong>: <strong><code>bufio</code> 通过在内存中增加一个缓冲区，将多次零散的 I&#x2F;O 操作合并为单次或少数几次大的 I&#x2F;O 操作，从而显著提高性能。</strong></p>
<hr>
<h3 id="第二阶段：认识三大主角"><a href="#第二阶段：认识三大主角" class="headerlink" title="第二阶段：认识三大主角"></a>第二阶段：认识三大主角</h3><p><code>bufio</code> 包主要提供了三个非常有用的类型，你需要分别了解它们：</p>
<ol>
<li><strong><code>bufio.Reader</code></strong>: 带缓冲区的读取器。</li>
<li><strong><code>bufio.Writer</code></strong>: 带缓冲区的写入器。</li>
<li><strong><code>bufio.Scanner</code></strong>: 一个更高级、更方便的工具，用于读取结构化的文本数据（比如按行、按单词读取）。</li>
</ol>
<hr>
<h3 id="第三阶段：动手实践（最重要的一步）"><a href="#第三阶段：动手实践（最重要的一步）" class="headerlink" title="第三阶段：动手实践（最重要的一步）"></a>第三阶段：动手实践（最重要的一步）</h3><p>现在，我们通过具体的代码来学习每个主角的用法。</p>
<h4 id="1-bufio-Reader：更灵活的读取"><a href="#1-bufio-Reader：更灵活的读取" class="headerlink" title="1. bufio.Reader：更灵活的读取"></a>1. <code>bufio.Reader</code>：更灵活的读取</h4><p><code>Reader</code> 适合需要对读取过程有更多控制的场景，比如读取到特定分隔符为止。</p>
<p><strong>创建方式</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">file, _ := os.Open(<span class="string">&quot;my_file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(file) <span class="comment">// 将一个 io.Reader 包装成 bufio.Reader</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong>:</p>
<ul>
<li><code>ReadString(delim byte)</code>: 读取直到第一次遇到 <code>delim</code> 字节，返回一个包含 <code>delim</code> 的字符串。<strong>按行读取文本文件是它的经典用法</strong>。</li>
<li><code>ReadLine()</code>: 一个更底层的按行读取方法，通常不推荐直接使用，<code>ReadString(&#39;\n&#39;)</code> 或 <code>Scanner</code> 更好。</li>
<li><code>ReadByte()</code>: 读取并返回一个字节。</li>
<li><code>Peek(n int)</code>: <strong>非常酷的功能！</strong> 它可以“偷看”接下来的 <code>n</code> 个字节，但<strong>不移动读取指针</strong>。也就是说，下次再读，还是从这 <code>n</code> 个字节开始。</li>
</ul>
<p><strong>实战代码：使用 <code>ReadString</code> 按行读取文件</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 准备一个字符串源，实际中可以是 os.File</span></span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;第一行\n第二行\n第三行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    reader := bufio.NewReader(r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读取直到遇到换行符</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123; <span class="comment">// io.EOF 表示文件已经读完</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                fmt.Print(line) <span class="comment">// 打印最后一行（可能没有换行符）</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(<span class="string">&quot;文件读取完成&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;读取文件时发生错误:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ReadString 返回的行会包含分隔符本身，我们通常需要去掉它</span></span><br><span class="line">        fmt.Print(strings.TrimSpace(line))</span><br><span class="line">        fmt.Println(<span class="string">&quot; (已读取一行)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-bufio-Scanner：现代、简洁的文本读取利器"><a href="#2-bufio-Scanner：现代、简洁的文本读取利器" class="headerlink" title="2. bufio.Scanner：现代、简洁的文本读取利器"></a>2. <code>bufio.Scanner</code>：现代、简洁的文本读取利器</h4><p>对于按行、按单词读取文本这种常见需求，<code>Scanner</code> 是<strong>首选方案</strong>。它更简单、性能更好，并且能正确处理 <code>\n</code> 和 <code>\r\n</code> 换行符。</p>
<p><strong>创建方式</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">file, _ := os.Open(<span class="string">&quot;my_file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">scanner := bufio.NewScanner(file) <span class="comment">// 将一个 io.Reader 包装成 bufio.Scanner</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong>:</p>
<ul>
<li><code>Scan() bool</code>: 扫描到下一个“令牌”（默认是行），如果成功则返回 <code>true</code>。它通常用在 <code>for</code> 循环的条件里。</li>
<li><code>Text() string</code>: 返回最近一次 <code>Scan()</code> 扫描到的令牌（行）的字符串内容。</li>
<li><code>Bytes() []byte</code>: 功能同 <code>Text()</code>，但返回字节切片。</li>
<li><code>Err() error</code>: 返回扫描过程中遇到的错误。</li>
</ul>
<p><strong>实战代码：使用 <code>Scanner</code> 按行读取文件（推荐方式）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">&quot;苹果\n香蕉\n橘子&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    scanner := bufio.NewScanner(r)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for scanner.Scan() 是 Go 中读取文本的惯用写法 (idiom)</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        line := scanner.Text() <span class="comment">// 获取当前行内容</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;扫描到一行: %s\n&quot;</span>, line)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描结束后，检查是否有错误发生</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;扫描时发生错误:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进阶</strong>: <code>scanner.Split()</code> 方法可以让你自定义分割规则，比如按单词、按逗号等。</p>
<h4 id="3-bufio-Writer：高效写入"><a href="#3-bufio-Writer：高效写入" class="headerlink" title="3. bufio.Writer：高效写入"></a>3. <code>bufio.Writer</code>：高效写入</h4><p><code>Writer</code> 的核心在于它的缓冲区。数据先写入内存，直到缓冲区满了或你手动“刷新”，才会真正写入底层的文件或网络连接。</p>
<p><strong>创建方式</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">file, _ := os.Create(<span class="string">&quot;output.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(file)</span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong>:</p>
<ul>
<li><code>WriteString(s string)</code>: 将字符串写入缓冲区。</li>
<li><code>Write(p []byte)</code>: 将字节切片写入缓冲区。</li>
<li><code>Flush()</code>: <strong>至关重要的方法！</strong> 将缓冲区中所有的数据立刻写入底层的 <code>io.Writer</code>（例如文件）。<strong>忘记调用 <code>Flush</code> 是最常见的错误！</strong></li>
</ul>
<p><strong>实战代码：使用 <code>Writer</code> 高效写入文件</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Create(<span class="string">&quot;output.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入几行字符串到缓冲区</span></span><br><span class="line">    _, _ = writer.WriteString(<span class="string">&quot;Hello, bufio!\n&quot;</span>)</span><br><span class="line">    _, _ = writer.WriteString(<span class="string">&quot;这是第二行。\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;数据已写入缓冲区，但尚未写入文件。&quot;</span>)</span><br><span class="line">    <span class="comment">// 此时打开 output.txt，你会发现文件是空的！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Flush 将缓冲区内容写入文件</span></span><br><span class="line">    err = writer.Flush()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Flush() 已调用，数据已成功写入文件。&quot;</span>)</span><br><span class="line">    <span class="comment">// 现在打开 output.txt，内容就在里面了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最佳实践</strong>: 使用 <code>defer</code> 来确保 <code>Flush</code> 总能被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, _ := os.Create(<span class="string">&quot;output.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    </span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line">    <span class="keyword">defer</span> writer.Flush() <span class="comment">// &lt;--- 使用 defer 确保在函数退出前刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">    writer.WriteString(<span class="string">&quot;这样写更安全！\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第四阶段：总结与选择"><a href="#第四阶段：总结与选择" class="headerlink" title="第四阶段：总结与选择"></a>第四阶段：总结与选择</h3><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">推荐工具</th>
<th align="left">为什么？</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>按行&#x2F;按单词读取文本文件</strong></td>
<td align="left"><strong><code>bufio.Scanner</code></strong></td>
<td align="left">代码最简洁、性能好、自动处理换行符，是首选。</td>
</tr>
<tr>
<td align="left">需要<strong>读取到特定字符</strong>为止</td>
<td align="left"><code>bufio.Reader</code></td>
<td align="left"><code>ReadString</code> 方法完美匹配此需求。</td>
</tr>
<tr>
<td align="left">需要**“偷看”**后面的数据而不移动指针</td>
<td align="left"><code>bufio.Reader</code></td>
<td align="left">只有 <code>Reader</code> 提供 <code>Peek</code> 功能。</td>
</tr>
<tr>
<td align="left"><strong>大量、频繁地写入小数据</strong>到文件或网络</td>
<td align="left"><strong><code>bufio.Writer</code></strong></td>
<td align="left">显著提升写入性能，减少系统调用。</td>
</tr>
<tr>
<td align="left">读取整个小文件</td>
<td align="left"><code>os.ReadFile</code></td>
<td align="left">如果文件不大，一次性读入内存更简单，没必要用 <code>bufio</code>。</td>
</tr>
</tbody></table>
<p><strong>学习建议</strong>:</p>
<ol>
<li>亲手把上面的每一段代码都敲一遍，并尝试修改它（比如换成真实的文件操作）。</li>
<li>理解 <code>Flush</code> 的重要性，并尝试不调用它看看会发生什么。</li>
<li>练习用 <code>Scanner</code> 读取标准输入 <code>os.Stdin</code>。</li>
</ol>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>总结来说，我只需要创建bufio.Reader: 带缓冲区的读取器。<br>bufio.Writer: 带缓冲区的写入器。<br>bufio.Scanner: 一个更高级、更方便的工具，用于读取结构化的文本数据（比如按行、按单词读取）。这三个东西，然后按照需求调用相应的函数就行了是吧</p>
<p>是的，你的总结非常精准！<strong>完全正确</strong>。</p>
<p><code>bufio</code> 包的学习和使用核心，就是围绕这三个“主角”展开的。你可以把它们理解为你工具箱里三种不同但相关的工具：</p>
<ol>
<li><p><strong><code>bufio.Reader</code> (带缓冲区的读取器)</strong></p>
<ul>
<li><strong>核心功能</strong>: 提供一个缓冲区来加速底层 <code>io.Reader</code> 的读取操作。</li>
<li><strong>何时使用</strong>: 当你需要比 <code>Scanner</code> 更底层的控制时，比如：<ul>
<li>读取到任意定的分隔符为止 (<code>ReadString</code>)。</li>
<li>需要“偷窥”数据流而不消耗它 (<code>Peek</code>)。</li>
<li>按特定字节数读取 (<code>Read</code>)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>bufio.Writer</code> (带缓冲区的写入器)</strong></p>
<ul>
<li><strong>核心功能</strong>: 提供一个缓冲区来加速底层 <code>io.Writer</code> 的写入操作。</li>
<li><strong>何时使用</strong>: 当你需要向文件或网络连接进行<strong>大量、零碎的写入</strong>时。它能把这些零碎的写入合并成大的块，一次性发送，性能提升巨大。</li>
<li><strong>必须记住</strong>: <strong>用完一定要调用 <code>Flush()</code></strong>，否则缓冲区的数据会丢失！最稳妥的方式是 <code>defer writer.Flush()</code>。</li>
</ul>
</li>
<li><p><strong><code>bufio.Scanner</code> (高级文本扫描器)</strong></p>
<ul>
<li><strong>核心功能</strong>: 专门用于<strong>读取结构化的文本数据</strong>。</li>
<li><strong>何时使用</strong>: 这是<strong>处理文本文件最常用、最推荐</strong>的工具。<ul>
<li>按行读取文件或标准输入（最常见的场景）。</li>
<li>按单词、逗号或其他自定义规则分割文本。</li>
</ul>
</li>
<li><strong>优点</strong>: 接口极其简洁（<code>for scanner.Scan()</code> 循环），性能好，自动处理各种换行符问题，不容易出错。</li>
</ul>
</li>
</ol>
<h3 id="你的学习和使用流程就是："><a href="#你的学习和使用流程就是：" class="headerlink" title="你的学习和使用流程就是："></a>你的学习和使用流程就是：</h3><ol>
<li><p><strong>明确你的 I&#x2F;O 需求</strong>:</p>
<ul>
<li>“我要读取一个大文本文件，一行一行地处理。” -&gt; <strong>选择 <code>bufio.Scanner</code></strong>。</li>
<li>“我要向一个文件里循环写入上万条日志。” -&gt; <strong>选择 <code>bufio.Writer</code></strong>。</li>
<li>“我要从一个网络连接中读取数据，直到遇到一个特定的字节 <code>0xFF</code> 为止。” -&gt; <strong>选择 <code>bufio.Reader</code></strong>。</li>
</ul>
</li>
<li><p><strong>创建实例</strong>:</p>
<ul>
<li>找到你的原始 <code>io.Reader</code>（如 <code>os.File</code>, <code>strings.Reader</code>, <code>net.Conn</code>）或 <code>io.Writer</code>。</li>
<li>调用 <code>bufio.NewScanner(reader)</code>, <code>bufio.NewReader(reader)</code> 或 <code>bufio.NewWriter(writer)</code> 来“包装”它，得到一个带缓冲区的增强版工具。</li>
</ul>
</li>
<li><p><strong>调用方法</strong>:</p>
<ul>
<li>根据你的具体需求，调用对应工具的方法（如 <code>scanner.Scan()</code>, <code>reader.ReadString()</code>, <code>writer.WriteString()</code>）。</li>
</ul>
</li>
<li><p><strong>收尾工作</strong>:</p>
<ul>
<li>如果是 <code>Writer</code>，<strong>务必 <code>Flush()</code></strong>。</li>
<li>如果是 <code>Scanner</code>，最好检查一下 <code>scanner.Err()</code>。</li>
<li>记得关闭底层的 <code>io.Closer</code>（如 <code>file.Close()</code>）。</li>
</ul>
</li>
</ol>
<p>所以，你完全掌握了 <code>bufio</code> 的精髓。剩下的就是在实际编码中多加练习，熟悉这三个工具的常用方法，你就能在 Go I&#x2F;O 编程中游刃有余了。</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>就是传入的东西，然后赋予的值，读取或者写入的角色我不是很清楚</p>
<p>你提出了一个非常关键的概念性问题，很多初学者都会在这里感到困惑。我们来彻底把它弄明白。</p>
<p><code>bufio</code> 的所有工具（Reader, Writer, Scanner）都扮演着一个**“中间人”<strong>或者说</strong>“加工者”<strong>的角色。它们本身不是数据的来源或目的地，而是对数据的流动进行</strong>“增强”<strong>或</strong>“包装”**。</p>
<p>让我们用一个生动的比喻来解释：<strong>自来水系统</strong>。</p>
<ul>
<li><strong>数据源 (比如文件 <code>os.File</code>)</strong>：就像是<strong>市政供水管道</strong>。水（数据）在里面，但水压可能不稳定，开关一次成本很高（系统调用）。</li>
<li><strong><code>bufio.Reader</code></strong>：就像是你家厨房水槽上的<strong>带蓄水池的净水器</strong>。</li>
<li><strong>你的程序</strong>：就是<strong>你</strong>，想要接水喝。</li>
</ul>
<hr>
<h3 id="1-bufio-Reader-带蓄水池的净水器"><a href="#1-bufio-Reader-带蓄水池的净水器" class="headerlink" title="1. bufio.Reader (带蓄水池的净水器)"></a>1. <code>bufio.Reader</code> (带蓄水池的净水器)</h3><p><strong><code>传入的东西</code></strong>: <code>os.File</code> (市政供水管道)<br><strong><code>赋予的值</code></strong>: <code>bufio.Reader</code> (带蓄水池的净水器)<br><strong><code>角色</code></strong>: 读取的角色</p>
<p><strong>流程解释</strong>:</p>
<ol>
<li><p><code>reader := bufio.NewReader(file)</code></p>
<ul>
<li><strong>你做了什么</strong>：你把<strong>市政供水管道 (<code>file</code>)</strong> 接到了<strong>净水器 (<code>bufio.Reader</code>)</strong> 的进水口。</li>
<li><strong>发生了什么</strong>：<code>bufio.Reader</code> 内部立刻从 <code>file</code> 里“猛吸”一大口水（比如4KB的数据）到自己的**蓄水池（缓冲区）**里，然后关上阀门。它只和市政管道交互了这一次，成本很低。</li>
</ul>
</li>
<li><p><code>line, _ := reader.ReadString(&#39;\n&#39;)</code></p>
<ul>
<li><strong>你做了什么</strong>：你按下了净水器上的“出水”按钮，想要接一杯水（一行数据）。</li>
<li><strong>发生了什么</strong>：净水器<strong>直接从它自己的蓄水池里</strong>给你放水，直到遇到换行符。这个过程非常快，因为它操作的是内存里的蓄水池，根本没有去碰那个开关成本很高的市政管道。</li>
<li><strong>如果蓄水池空了怎么办？</strong>：只有当蓄水池里的水不够你接一杯时，净水器才会再次打开阀门，从市政管道里再“猛吸”一大口水进来，然后再从新的蓄水池里给你放水。</li>
</ul>
</li>
</ol>
<p><strong>总结 <code>Reader</code> 角色</strong>:<br>它是一个<strong>带缓冲区的读取代理</strong>。你不再直接从原始、低效的数据源读取，而是从这个高效的、带“蓄水池”的代理那里读取。它负责在背后管理与原始数据源的交互，为你屏蔽了复杂性和低效性。</p>
<hr>
<h3 id="2-bufio-Writer-带储压罐的热水器"><a href="#2-bufio-Writer-带储压罐的热水器" class="headerlink" title="2. bufio.Writer (带储压罐的热水器)"></a>2. <code>bufio.Writer</code> (带储压罐的热水器)</h3><p><strong><code>传入的东西</code></strong>: <code>os.File</code> (你家的排水管道)<br><strong><code>赋予的值</code></strong>: <code>bufio.Writer</code> (带储压罐的热水器)<br><strong><code>角色</code></strong>: 写入的角色</p>
<p><strong>流程解释</strong>:</p>
<ol>
<li><p><code>writer := bufio.NewWriter(file)</code></p>
<ul>
<li><strong>你做了什么</strong>：你把<strong>热水器的出水口 (<code>bufio.Writer</code>)</strong> 接到了<strong>你家的排水管道 (<code>file</code>)</strong>。</li>
<li><strong>发生了什么</strong>：<code>bufio.Writer</code> 准备好了自己的<strong>储压罐（缓冲区）</strong>。</li>
</ul>
</li>
<li><p><code>writer.WriteString(&quot;一些话\n&quot;)</code></p>
<ul>
<li><strong>你做了什么</strong>：你倒了一杯水（一些数据）到热水器的储压罐里。</li>
<li><strong>发生了什么</strong>：这杯水只是进入了储压罐，<strong>并没有流进排水管道</strong>。因为每次都去打开排水管道的阀门成本太高了。</li>
</ul>
</li>
<li><p><code>writer.Flush()</code></p>
<ul>
<li><strong>你做了什么</strong>：你按下了“<strong>冲洗&#x2F;排空</strong>”按钮。</li>
<li><strong>发生了什么</strong>：热水器打开阀门，<strong>一次性</strong>将储压罐里积攒的所有水，强力地冲入排水管道。这次交互虽然成本高，但我们只做了一次，而不是倒一杯水就冲一次。</li>
</ul>
</li>
</ol>
<p><strong>总结 <code>Writer</code> 角色</strong>:<br>它是一个<strong>带缓冲区的写入代理</strong>。你不再直接向原始、低效的目标写入，而是先把所有东西都“扔给”这个代理，它会帮你攒起来，最后在你需要的时候（或者攒满了的时候）一次性地、高效地写入最终目的地。</p>
<hr>
<h3 id="3-bufio-Scanner-智能饮水机"><a href="#3-bufio-Scanner-智能饮水机" class="headerlink" title="3. bufio.Scanner (智能饮水机)"></a>3. <code>bufio.Scanner</code> (智能饮水机)</h3><p><code>Scanner</code> 是 <code>Reader</code> 的一个更高级、更自动化的版本，特别适合处理文本。</p>
<p><strong><code>传入的东西</code></strong>: <code>os.File</code> (市政供水管道)<br><strong><code>赋予的值</code></strong>: <code>bufio.Scanner</code> (智能饮水机)<br><strong><code>角色</code></strong>: 一个更智能的读取角色</p>
<p><strong>流程解释</strong>:</p>
<ol>
<li><p><code>scanner := bufio.NewScanner(file)</code></p>
<ul>
<li>和 <code>Reader</code> 一样，你把<strong>市政管道 (<code>file</code>)</strong> 接到了<strong>智能饮水机 (<code>bufio.Scanner</code>)</strong>。它内部也有一个蓄水池（缓冲区），也会先猛吸一口水。</li>
</ul>
</li>
<li><p><code>for scanner.Scan()</code></p>
<ul>
<li><strong>你做了什么</strong>：你不停地按“接一杯”按钮。</li>
<li><strong>发生了什么</strong>：<code>scanner.Scan()</code> 会自动从蓄水池里帮你接好<strong>正好一杯</strong>（默认是一行）的水。如果成功接到，它就返回 <code>true</code>。你不需要关心它是怎么找到杯子边界（换行符）的，它都帮你处理好了。</li>
</ul>
</li>
<li><p><code>line := scanner.Text()</code></p>
<ul>
<li><strong>你做了什么</strong>：你把刚刚接好的那杯水拿起来喝。</li>
</ul>
</li>
</ol>
<p><strong>总结 <code>Scanner</code> 角色</strong>:<br>它是一个<strong>自动化的、面向文本的读取助手</strong>。你只需要不断地告诉它“给我下一个”，它就会自动、高效地从原始数据源中把格式化好的数据（比如一行行的文本）递给你。</p>
<h3 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h3><p><strong>“传入的东西”</strong> (<code>os.File</code>, <code>net.Conn</code>等) 是<strong>原始的数据源或目的地</strong>。它们是底层、直接的 I&#x2F;O 接口。</p>
<p><strong>“赋予的值”</strong> (<code>bufio.Reader</code>, <code>bufio.Writer</code>等) 是一个<strong>带缓冲区的、高效的代理</strong>。</p>
<p><strong>“角色”</strong>: <code>bufio</code> 的工具就是这个<strong>代理</strong>的角色。它夹在你和原始数据源之间，通过<strong>缓冲区</strong>这个核心机制，让你的数据读写变得更高效、更方便。你后续的所有 I&#x2F;O 操作，都应该通过这个“代理”来进行，而不是再回头去操作原始的那个 <code>file</code> 对象。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-08-25T07:29:11.000Z" title="8/25/2025, 3:29:11 PM">2025-08-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-25T07:32:35.914Z" title="8/25/2025, 3:32:35 PM">2025-08-25</time></span><span class="level-item">11 minutes read (About 1665 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/08/25/%E4%BD%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E9%AD%94%E5%8A%9B/">位掩码的魔力</a></p><div class="content"><h3 id="Go-log-SetFlags：为何它能用-合并参数？秒懂位掩码的魔力"><a href="#Go-log-SetFlags：为何它能用-合并参数？秒懂位掩码的魔力" class="headerlink" title="Go log.SetFlags：为何它能用 | 合并参数？秒懂位掩码的魔力"></a><strong>Go <code>log.SetFlags</code>：为何它能用 <code>|</code> 合并参数？秒懂位掩码的魔力</strong></h3><p>在使用 Go 语言进行开发时，标准库 <code>log</code> 是我们打交道的老朋友了。也许你曾无数次地写下或看到过下面这行熟悉的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">    log.Println(<span class="string">&quot;这是一条日志消息。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，你会得到类似这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2025/08/25 15:27:02.885249 /Users/cofeesy_zzz/Documents/go_project/my_demo/main.go:129: 这是一条日志消息。</span><br></pre></td></tr></table></figure>

<p>代码运行得完美无瑕，但你是否曾停下来，对 <code>log.Llongfile | log.Lmicroseconds | log.Ldate</code> 这部分代码产生过一丝好奇？</p>
<p><code>SetFlags</code> 函数的签名明明是 <code>func SetFlags(flag int)</code>，它只接受一个 <code>int</code> 类型的参数。我们为什么可以用 <code>|</code>（竖线）将好几个常量“连接”起来，看起来就像魔法一样传入了多个选项呢？</p>
<p>这背后并没有魔法，而是一个在计算机科学中广泛使用、既经典又高效的编程技巧——<strong>位掩码（Bitmask）</strong>。</p>
<p>今天，就让我们一起揭开它的神秘面纱！</p>
<h4 id="第一步：-不是普通的“或”"><a href="#第一步：-不是普通的“或”" class="headerlink" title="第一步：| 不是普通的“或”"></a><strong>第一步：<code>|</code> 不是普通的“或”</strong></h4><p>首先，我们需要明确一点：这里的 <code>|</code> 并不是我们在 <code>if</code> 语句中常见的逻辑或 <code>||</code>，也不是某个特殊的分隔符。它是一个<strong>位运算符</strong>，学名叫“<strong>按位或（Bitwise OR）</strong>”。</p>
<p>它的工作原理非常简单：将两个数字转换为二进制，然后逐位进行比较。只要对应位上<strong>有一个是 1</strong>，结果的对应位就<strong>是 1</strong>。</p>
<p>举个例子，计算 <code>5 | 3</code>：</p>
<ol>
<li><p>将 <code>5</code> 和 <code>3</code> 转换为二进制：</p>
<ul>
<li><code>5</code> &#x3D; <code>0101</code></li>
<li><code>3</code> &#x3D; <code>0011</code></li>
</ul>
</li>
<li><p>逐位进行“或”运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0101  (5)</span><br><span class="line">| 0011  (3)</span><br><span class="line">---------</span><br><span class="line">  0111  (7)</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以，<code>5 | 3</code> 的结果是 <code>7</code>。</p>
</li>
</ol>
<p><code>|</code> 操作符是解开谜题的钥匙，但真正让这把钥匙能开锁的，是那些 <code>log</code> 常量的巧妙设计。</p>
<h4 id="第二步：藏在常量里的“秘密”"><a href="#第二步：藏在常量里的“秘密”" class="headerlink" title="第二步：藏在常量里的“秘密”"></a><strong>第二步：藏在常量里的“秘密”</strong></h4><p>让我们深入 <code>log</code> 包的源码，看看这些常量的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From src/log/log.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">    Ltime         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">    Lmicroseconds = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// microsecond resolution: 01:23:23.123123.</span></span><br><span class="line">    Llongfile     = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// full file name and line number: /a/b/c/d.go:23</span></span><br><span class="line">    Lshortfile    = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">// final file name element and line number: d.go:23</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里的 <code>iota</code> 是 Go 语言中一个神奇的常量计数器，默认从 0 开始。而 <code>&lt;&lt;</code> 是<strong>左移位运算符</strong>。<code>1 &lt;&lt; iota</code> 的意思就是将数字 <code>1</code> 的二进制表示向左移动 <code>iota</code> 位。</p>
<p>让我们把这些常量的值算出来，看看它们的二进制形式：</p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>计算过程</th>
<th>十进制值</th>
<th>二进制表示</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ldate</code></td>
<td><code>1 &lt;&lt; 0</code></td>
<td>1</td>
<td><code>0000 0001</code></td>
</tr>
<tr>
<td><code>Ltime</code></td>
<td><code>1 &lt;&lt; 1</code></td>
<td>2</td>
<td><code>0000 0010</code></td>
</tr>
<tr>
<td><code>Lmicroseconds</code></td>
<td><code>1 &lt;&lt; 2</code></td>
<td>4</td>
<td><code>0000 0100</code></td>
</tr>
<tr>
<td><code>Llongfile</code></td>
<td><code>1 &lt;&lt; 3</code></td>
<td>8</td>
<td><code>0000 1000</code></td>
</tr>
<tr>
<td><code>Lshortfile</code></td>
<td><code>1 &lt;&lt; 4</code></td>
<td>16</td>
<td><code>0001 0000</code></td>
</tr>
</tbody></table>
<p>发现规律了吗？</p>
<p><strong>每个常量在二进制形式下，都只有一个位是 <code>1</code>，并且这个 <code>1</code> 所在的位置是独一无二、互不冲突的！</strong></p>
<h4 id="第三步：开关面板的比喻"><a href="#第三步：开关面板的比喻" class="headerlink" title="第三步：开关面板的比喻"></a><strong>第三步：开关面板的比喻</strong></h4><p>现在，让我们用一个生动的比喻来理解这一切。</p>
<p>想象一个 <code>int</code> 整数就是一个拥有 32 个（或 64 个）灯泡的<strong>开关面板</strong>。每个灯泡的位置（即二进制位）都代表一个特定的功能。</p>
<ul>
<li><code>Ldate</code> 的值是 1 (<code>...0001</code>)，它代表“<strong>打开最右边第 1 个灯泡</strong>”的指令。</li>
<li><code>Lmicroseconds</code> 的值是 4 (<code>...0100</code>)，它代表“<strong>打开从右数第 3 个灯泡</strong>”的指令。</li>
<li><code>Llongfile</code> 的值是 8 (<code>...1000</code>)，它代表“<strong>打开从右数第 4 个灯泡</strong>”的指令。</li>
</ul>
<p>而我们使用的 <code>|</code>（按位或）操作，就相当于<strong>同时按下这几个开关</strong>！</p>
<p>当我们执行 <code>log.Llongfile | log.Lmicroseconds | log.Ldate</code> 时，计算机内部发生了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    0000 1000  (Llongfile: 打开第4个灯)</span><br><span class="line">|   0000 0100  (Lmicroseconds: 打开第3个灯)</span><br><span class="line">|   0000 0001  (Ldate: 打开第1个灯)</span><br><span class="line">------------------</span><br><span class="line">    0000 1101  (最终状态)</span><br></pre></td></tr></table></figure>

<p>这个结果 <code>0000 1101</code>（十进制为 13），就是一个包含了所有选项信息的<strong>单一整数</strong>。它像一张状态快照，完美地记录了“第1、3、4号灯泡都亮着”这个事实。</p>
<p>所以，<code>log.SetFlags(...)</code> 这行代码，最终只向函数传递了一个 <code>int</code> 值：<code>13</code>。</p>
<h4 id="第四步：函数内部如何“读懂”你"><a href="#第四步：函数内部如何“读懂”你" class="headerlink" title="第四步：函数内部如何“读懂”你"></a><strong>第四步：函数内部如何“读懂”你</strong></h4><p>好了，<code>SetFlags</code> 函数收到了整数 <code>13</code>。它又是如何知道我们要的是“日期”、“微秒”和“长文件名”这三个选项呢？</p>
<p>答案是另一个位运算符：<code>&amp;</code>（<strong>按位与，Bitwise AND</strong>）。</p>
<p><code>&amp;</code> 的规则是：两个二进制数的对应位，<strong>只有都是 1</strong>，结果的对应位<strong>才是 1</strong>，否则为 0。</p>
<p><code>SetFlags</code> 函数内部会用收到的参数 <code>flag</code> 和每一个常量进行 <code>&amp;</code> 运算，来检查对应的“开关”是否打开：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数内部逻辑的伪代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span></span> SetFlags(flag <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查是否需要显示日期</span></span><br><span class="line">    <span class="comment">// 13 &amp; 1  -&gt;  (0000 1101 &amp; 0000 0001) -&gt; 0000 0001 (结果不为0)</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; Ldate) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 条件成立！开启显示日期的功能</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要显示时间</span></span><br><span class="line">    <span class="comment">// 13 &amp; 2  -&gt;  (0000 1101 &amp; 0000 0010) -&gt; 0000 0000 (结果为0)</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; Ltime) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 条件不成立，跳过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要显示微秒</span></span><br><span class="line">    <span class="comment">// 13 &amp; 4  -&gt;  (0000 1101 &amp; 0000 0100) -&gt; 0000 0100 (结果不为0)</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; Lmicroseconds) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 条件成立！开启显示微秒的功能</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 以此类推</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，函数就能精确地解析出我们通过 <code>|</code> 组合起来的所有选项。</p>
<h4 id="总结：为何要使用位掩码？"><a href="#总结：为何要使用位掩码？" class="headerlink" title="总结：为何要使用位掩码？"></a><strong>总结：为何要使用位掩码？</strong></h4><p>位掩码是一种非常优雅的编程技巧，它的优点显而易见：</p>
<ol>
<li><strong>高效性</strong>：用一个整数就可以打包传递多个布尔型的选项，极大地节省了空间，也让函数调用更简洁。</li>
<li><strong>可扩展性</strong>：如果未来 <code>log</code> 包想增加一个新的日志选项，只需定义一个新的、二进制位不冲突的常量即可，完全不会影响现有的函数签名和代码。</li>
<li><strong>可读性</strong>：相比于 <code>SetOptions(true, false, true, true)</code> 这样的长串布尔参数，<code>OptA | OptB | OptC</code> 的写法显然更清晰，意图也更明确。</li>
</ol>
<p>这种技巧在各种编程场景中都屡见不鲜，例如 Linux&#x2F;Unix 系统的文件权限（<code>rwx</code> -&gt; <code>421</code>），各种图形库的渲染标志，以及网络协议的控制位等等。</p>
<p>现在，当你再次看到 <code>flag1 | flag2</code> 这样的代码时，希望你脑海中浮现的不再是神秘的符号，而是一块清晰明了、亮着不同灯光的二进制开关面板。这，就是位掩码的魅力所在！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-08-17T07:45:14.657Z" title="8/17/2025, 3:45:14 PM">2025-08-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-08-17T07:45:14.657Z" title="8/17/2025, 3:45:14 PM">2025-08-17</time></span><span class="level-item">a minute read (About 123 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/08/17/hello-world/">Hello World</a></p><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Cofeesy"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Cofeesy</p><p class="is-size-6 is-block">Recording Station</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shenzhen, Guangdong Province</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/Cofeesy"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://x.com/Cofessy_zzz"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-25T09:22:57.000Z">2025-08-25</time></p><p class="title"><a href="/2025/08/25/%E5%88%9D%E5%AD%A6flag%E5%8C%85/">初学flag包</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-25T08:42:09.000Z">2025-08-25</time></p><p class="title"><a href="/2025/08/25/%E5%88%9D%E5%AD%A6bufio%E5%8C%85/">初学bufio包</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-25T07:29:11.000Z">2025-08-25</time></p><p class="title"><a href="/2025/08/25/%E4%BD%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E9%AD%94%E5%8A%9B/">位掩码的魔力</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-17T07:45:14.657Z">2025-08-17</time></p><p class="title"><a href="/2025/08/17/hello-world/">Hello World</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/08/"><span class="level-start"><span class="level-item">August 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2025 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>