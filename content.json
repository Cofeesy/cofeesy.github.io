{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/08/17/hello-world/"},{"title":"位掩码的魔力","text":"Go log.SetFlags：为何它能用 | 合并参数？秒懂位掩码的魔力在使用 Go 语言进行开发时，标准库 log 是我们打交道的老朋友了。也许你曾无数次地写下或看到过下面这行熟悉的代码： 123456import &quot;log&quot;func main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(&quot;这是一条日志消息。&quot;)} 运行后，你会得到类似这样的输出： 12025/08/25 15:27:02.885249 /Users/cofeesy_zzz/Documents/go_project/my_demo/main.go:129: 这是一条日志消息。 代码运行得完美无瑕，但你是否曾停下来，对 log.Llongfile | log.Lmicroseconds | log.Ldate 这部分代码产生过一丝好奇？ SetFlags 函数的签名明明是 func SetFlags(flag int)，它只接受一个 int 类型的参数。我们为什么可以用 |（竖线）将好几个常量“连接”起来，看起来就像魔法一样传入了多个选项呢？ 这背后并没有魔法，而是一个在计算机科学中广泛使用、既经典又高效的编程技巧——位掩码（Bitmask）。 今天，就让我们一起揭开它的神秘面纱！ 第一步：| 不是普通的“或”首先，我们需要明确一点：这里的 | 并不是我们在 if 语句中常见的逻辑或 ||，也不是某个特殊的分隔符。它是一个位运算符，学名叫“按位或（Bitwise OR）”。 它的工作原理非常简单：将两个数字转换为二进制，然后逐位进行比较。只要对应位上有一个是 1，结果的对应位就是 1。 举个例子，计算 5 | 3： 将 5 和 3 转换为二进制： 5 = 0101 3 = 0011 逐位进行“或”运算： 1234 0101 (5)| 0011 (3)--------- 0111 (7) 所以，5 | 3 的结果是 7。 | 操作符是解开谜题的钥匙，但真正让这把钥匙能开锁的，是那些 log 常量的巧妙设计。 第二步：藏在常量里的“秘密”让我们深入 log 包的源码，看看这些常量的定义： 123456789// From src/log/log.goconst ( Ldate = 1 &lt;&lt; iota // the date in the local time zone: 2009/01/23 Ltime = 1 &lt;&lt; iota // the time in the local time zone: 01:23:23 Lmicroseconds = 1 &lt;&lt; iota // microsecond resolution: 01:23:23.123123. Llongfile = 1 &lt;&lt; iota // full file name and line number: /a/b/c/d.go:23 Lshortfile = 1 &lt;&lt; iota // final file name element and line number: d.go:23 // ...) 这里的 iota 是 Go 语言中一个神奇的常量计数器，默认从 0 开始。而 &lt;&lt; 是左移位运算符。1 &lt;&lt; iota 的意思就是将数字 1 的二进制表示向左移动 iota 位。 让我们把这些常量的值算出来，看看它们的二进制形式： 常量名 计算过程 十进制值 二进制表示 Ldate 1 &lt;&lt; 0 1 0000 0001 Ltime 1 &lt;&lt; 1 2 0000 0010 Lmicroseconds 1 &lt;&lt; 2 4 0000 0100 Llongfile 1 &lt;&lt; 3 8 0000 1000 Lshortfile 1 &lt;&lt; 4 16 0001 0000 发现规律了吗？ 每个常量在二进制形式下，都只有一个位是 1，并且这个 1 所在的位置是独一无二、互不冲突的！ 第三步：开关面板的比喻现在，让我们用一个生动的比喻来理解这一切。 想象一个 int 整数就是一个拥有 32 个（或 64 个）灯泡的开关面板。每个灯泡的位置（即二进制位）都代表一个特定的功能。 Ldate 的值是 1 (...0001)，它代表“打开最右边第 1 个灯泡”的指令。 Lmicroseconds 的值是 4 (...0100)，它代表“打开从右数第 3 个灯泡”的指令。 Llongfile 的值是 8 (...1000)，它代表“打开从右数第 4 个灯泡”的指令。 而我们使用的 |（按位或）操作，就相当于同时按下这几个开关！ 当我们执行 log.Llongfile | log.Lmicroseconds | log.Ldate 时，计算机内部发生了： 12345 0000 1000 (Llongfile: 打开第4个灯)| 0000 0100 (Lmicroseconds: 打开第3个灯)| 0000 0001 (Ldate: 打开第1个灯)------------------ 0000 1101 (最终状态) 这个结果 0000 1101（十进制为 13），就是一个包含了所有选项信息的单一整数。它像一张状态快照，完美地记录了“第1、3、4号灯泡都亮着”这个事实。 所以，log.SetFlags(...) 这行代码，最终只向函数传递了一个 int 值：13。 第四步：函数内部如何“读懂”你好了，SetFlags 函数收到了整数 13。它又是如何知道我们要的是“日期”、“微秒”和“长文件名”这三个选项呢？ 答案是另一个位运算符：&amp;（按位与，Bitwise AND）。 &amp; 的规则是：两个二进制数的对应位，只有都是 1，结果的对应位才是 1，否则为 0。 SetFlags 函数内部会用收到的参数 flag 和每一个常量进行 &amp; 运算，来检查对应的“开关”是否打开： 12345678910111213141516171819202122// 函数内部逻辑的伪代码演示func (l *Logger) SetFlags(flag int) { // 检查是否需要显示日期 // 13 &amp; 1 -&gt; (0000 1101 &amp; 0000 0001) -&gt; 0000 0001 (结果不为0) if (flag &amp; Ldate) != 0 { // 条件成立！开启显示日期的功能 } // 检查是否需要显示时间 // 13 &amp; 2 -&gt; (0000 1101 &amp; 0000 0010) -&gt; 0000 0000 (结果为0) if (flag &amp; Ltime) != 0 { // 条件不成立，跳过 } // 检查是否需要显示微秒 // 13 &amp; 4 -&gt; (0000 1101 &amp; 0000 0100) -&gt; 0000 0100 (结果不为0) if (flag &amp; Lmicroseconds) != 0 { // 条件成立！开启显示微秒的功能 } // ... 以此类推} 通过这种方式，函数就能精确地解析出我们通过 | 组合起来的所有选项。 总结：为何要使用位掩码？位掩码是一种非常优雅的编程技巧，它的优点显而易见： 高效性：用一个整数就可以打包传递多个布尔型的选项，极大地节省了空间，也让函数调用更简洁。 可扩展性：如果未来 log 包想增加一个新的日志选项，只需定义一个新的、二进制位不冲突的常量即可，完全不会影响现有的函数签名和代码。 可读性：相比于 SetOptions(true, false, true, true) 这样的长串布尔参数，OptA | OptB | OptC 的写法显然更清晰，意图也更明确。 这种技巧在各种编程场景中都屡见不鲜，例如 Linux/Unix 系统的文件权限（rwx -&gt; 421），各种图形库的渲染标志，以及网络协议的控制位等等。 现在，当你再次看到 flag1 | flag2 这样的代码时，希望你脑海中浮现的不再是神秘的符号，而是一块清晰明了、亮着不同灯光的二进制开关面板。这，就是位掩码的魅力所在！","link":"/2025/08/25/%E4%BD%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E9%AD%94%E5%8A%9B/"}],"tags":[],"categories":[],"pages":[]}