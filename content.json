{"posts":[{"title":"cookie_and_session","text":"标准 Session 工作流程 客户端首次请求 (Client’s First Request) 用户通过浏览器第一次访问服务器。 服务器端操作 (Server-Side Actions) 创建 Session ID: 服务器为该用户生成一个全局唯一且难以预测的字符串，这就是 Session ID。 创建 Session 存储: 服务器在自己的存储（内存、Redis、文件系统、数据库等）中开辟一块空间，创建一个与该 Session ID 关联的“档案”。这个档案目前是空的，等待存放用户数据。 创建 Cookie: 服务器创建一个新的 Cookie。这个 Cookie 最关键的内容就是 name=SESSION_ID（或者 jsessionid 等，名字可自定义）和 value=&lt;刚刚生成的那个唯一的Session ID&gt;。 发送响应: 服务器将这个带有 Session ID 的 Cookie 放入 HTTP 响应的 Set-Cookie 头部，然后将响应发送回客户端。 客户端存储 (Client-Side Storage) 浏览器收到服务器的响应后，解析 Set-Cookie 头部，并将这个包含 Session ID 的 Cookie 存储在本地。 客户端后续请求 (Client’s Subsequent Requests) 当用户在该网站上进行任何后续操作（点击链接、提交表单等）时，浏览器会自动地、在每一个发往该网站的 HTTP 请求的 Cookie 头部，都附上之前存储的那个含有 Session ID 的 Cookie。 服务器端验证与使用 (Server-Side Verification &amp; Usage) 服务器接收到新的请求。 解析 Cookie: 服务器从请求的 Cookie 头部中提取出 Session ID 的值。 查找档案: 服务器拿着这个 Session ID，去自己的存储中查找对应的“档案”。.a. 如果找到: 说明用户是“老朋友”，服务器就可以读取或修改这份档案里的数据（比如检查登录状态、更新购物车），然后处理业务逻辑。.b. 如果没找到: （可能因为 Session 过期被清理，或者客户端发送了一个伪造的/无效的 ID），服务器会认为这是一个无效的会话，通常会强制用户重新登录，或者为他创建一个全新的 Session（回到第2步）。 你的理解完全到位，没有任何偏差。这就是现代 Web 应用中最基础、最核心的状态管理机制。掌握了这个流程，你就理解了绝大多数网站“登录”功能的底层原理。","link":"/2025/08/28/cookie-and-session/"},{"title":"位掩码的魔力","text":"Go log.SetFlags：为何它能用 | 合并参数？秒懂位掩码的魔力在使用 Go 语言进行开发时，标准库 log 是我们打交道的老朋友了。也许你曾无数次地写下或看到过下面这行熟悉的代码： 123456import &quot;log&quot;func main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(&quot;这是一条日志消息。&quot;)} 运行后，你会得到类似这样的输出： 12025/08/25 15:27:02.885249 /Users/cofeesy_zzz/Documents/go_project/my_demo/main.go:129: 这是一条日志消息。 代码运行得完美无瑕，但你是否曾停下来，对 log.Llongfile | log.Lmicroseconds | log.Ldate 这部分代码产生过一丝好奇？ SetFlags 函数的签名明明是 func SetFlags(flag int)，它只接受一个 int 类型的参数。我们为什么可以用 |（竖线）将好几个常量“连接”起来，看起来就像魔法一样传入了多个选项呢？ 这背后并没有魔法，而是一个在计算机科学中广泛使用、既经典又高效的编程技巧——位掩码（Bitmask）。 今天，就让我们一起揭开它的神秘面纱！ 第一步：| 不是普通的“或”首先，我们需要明确一点：这里的 | 并不是我们在 if 语句中常见的逻辑或 ||，也不是某个特殊的分隔符。它是一个位运算符，学名叫“按位或（Bitwise OR）”。 它的工作原理非常简单：将两个数字转换为二进制，然后逐位进行比较。只要对应位上有一个是 1，结果的对应位就是 1。 举个例子，计算 5 | 3： 将 5 和 3 转换为二进制： 5 = 0101 3 = 0011 逐位进行“或”运算： 1234 0101 (5)| 0011 (3)--------- 0111 (7) 所以，5 | 3 的结果是 7。 | 操作符是解开谜题的钥匙，但真正让这把钥匙能开锁的，是那些 log 常量的巧妙设计。 第二步：藏在常量里的“秘密”让我们深入 log 包的源码，看看这些常量的定义： 123456789// From src/log/log.goconst ( Ldate = 1 &lt;&lt; iota // the date in the local time zone: 2009/01/23 Ltime = 1 &lt;&lt; iota // the time in the local time zone: 01:23:23 Lmicroseconds = 1 &lt;&lt; iota // microsecond resolution: 01:23:23.123123. Llongfile = 1 &lt;&lt; iota // full file name and line number: /a/b/c/d.go:23 Lshortfile = 1 &lt;&lt; iota // final file name element and line number: d.go:23 // ...) 这里的 iota 是 Go 语言中一个神奇的常量计数器，默认从 0 开始。而 &lt;&lt; 是左移位运算符。1 &lt;&lt; iota 的意思就是将数字 1 的二进制表示向左移动 iota 位。 让我们把这些常量的值算出来，看看它们的二进制形式： 常量名 计算过程 十进制值 二进制表示 Ldate 1 &lt;&lt; 0 1 0000 0001 Ltime 1 &lt;&lt; 1 2 0000 0010 Lmicroseconds 1 &lt;&lt; 2 4 0000 0100 Llongfile 1 &lt;&lt; 3 8 0000 1000 Lshortfile 1 &lt;&lt; 4 16 0001 0000 发现规律了吗？ 每个常量在二进制形式下，都只有一个位是 1，并且这个 1 所在的位置是独一无二、互不冲突的！ 第三步：开关面板的比喻现在，让我们用一个生动的比喻来理解这一切。 想象一个 int 整数就是一个拥有 32 个（或 64 个）灯泡的开关面板。每个灯泡的位置（即二进制位）都代表一个特定的功能。 Ldate 的值是 1 (...0001)，它代表“打开最右边第 1 个灯泡”的指令。 Lmicroseconds 的值是 4 (...0100)，它代表“打开从右数第 3 个灯泡”的指令。 Llongfile 的值是 8 (...1000)，它代表“打开从右数第 4 个灯泡”的指令。 而我们使用的 |（按位或）操作，就相当于同时按下这几个开关！ 当我们执行 log.Llongfile | log.Lmicroseconds | log.Ldate 时，计算机内部发生了： 12345 0000 1000 (Llongfile: 打开第4个灯)| 0000 0100 (Lmicroseconds: 打开第3个灯)| 0000 0001 (Ldate: 打开第1个灯)------------------ 0000 1101 (最终状态) 这个结果 0000 1101（十进制为 13），就是一个包含了所有选项信息的单一整数。它像一张状态快照，完美地记录了“第1、3、4号灯泡都亮着”这个事实。 所以，log.SetFlags(...) 这行代码，最终只向函数传递了一个 int 值：13。 第四步：函数内部如何“读懂”你好了，SetFlags 函数收到了整数 13。它又是如何知道我们要的是“日期”、“微秒”和“长文件名”这三个选项呢？ 答案是另一个位运算符：&amp;（按位与，Bitwise AND）。 &amp; 的规则是：两个二进制数的对应位，只有都是 1，结果的对应位才是 1，否则为 0。 SetFlags 函数内部会用收到的参数 flag 和每一个常量进行 &amp; 运算，来检查对应的“开关”是否打开： 12345678910111213141516171819202122// 函数内部逻辑的伪代码演示func (l *Logger) SetFlags(flag int) { // 检查是否需要显示日期 // 13 &amp; 1 -&gt; (0000 1101 &amp; 0000 0001) -&gt; 0000 0001 (结果不为0) if (flag &amp; Ldate) != 0 { // 条件成立！开启显示日期的功能 } // 检查是否需要显示时间 // 13 &amp; 2 -&gt; (0000 1101 &amp; 0000 0010) -&gt; 0000 0000 (结果为0) if (flag &amp; Ltime) != 0 { // 条件不成立，跳过 } // 检查是否需要显示微秒 // 13 &amp; 4 -&gt; (0000 1101 &amp; 0000 0100) -&gt; 0000 0100 (结果不为0) if (flag &amp; Lmicroseconds) != 0 { // 条件成立！开启显示微秒的功能 } // ... 以此类推} 通过这种方式，函数就能精确地解析出我们通过 | 组合起来的所有选项。 总结：为何要使用位掩码？位掩码是一种非常优雅的编程技巧，它的优点显而易见： 高效性：用一个整数就可以打包传递多个布尔型的选项，极大地节省了空间，也让函数调用更简洁。 可扩展性：如果未来 log 包想增加一个新的日志选项，只需定义一个新的、二进制位不冲突的常量即可，完全不会影响现有的函数签名和代码。 可读性：相比于 SetOptions(true, false, true, true) 这样的长串布尔参数，OptA | OptB | OptC 的写法显然更清晰，意图也更明确。 这种技巧在各种编程场景中都屡见不鲜，例如 Linux/Unix 系统的文件权限（rwx -&gt; 421），各种图形库的渲染标志，以及网络协议的控制位等等。 现在，当你再次看到 flag1 | flag2 这样的代码时，希望你脑海中浮现的不再是神秘的符号，而是一块清晰明了、亮着不同灯光的二进制开关面板。这，就是位掩码的魅力所在！","link":"/2025/08/25/%E4%BD%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E9%AD%94%E5%8A%9B/"},{"title":"初学bufio包","text":"第一阶段：理解核心思想 —— 为什么要用 bufio？在直接看代码之前，你必须先理解 bufio 存在的根本原因：减少系统调用，提升 I/O 性能。 想象一下你要从超市（磁盘）买100件商品（数据）。你有两种方式： 不用 bufio: 每次只拿一件商品，然后去收银台结账，来回100次。结账这个动作就像一次“系统调用（System Call）”，非常耗时。 使用 bufio: 你推一个购物车（缓冲区 Buffer），先把100件商品都放进购物车里，最后只去收银台结账一次。 bufio 包就是这个“购物车”。它在内存中开辟一块缓冲区，当你读取数据时，它会一次性从磁盘（或网络）读取一大块数据到缓冲区；当你写入数据时，它会先把数据写入缓冲区，等缓冲区满了或者你主动要求时，才一次性写入磁盘。 核心结论: bufio 通过在内存中增加一个缓冲区，将多次零散的 I/O 操作合并为单次或少数几次大的 I/O 操作，从而显著提高性能。 第二阶段：认识三大主角bufio 包主要提供了三个非常有用的类型，你需要分别了解它们： bufio.Reader: 带缓冲区的读取器。 bufio.Writer: 带缓冲区的写入器。 bufio.Scanner: 一个更高级、更方便的工具，用于读取结构化的文本数据（比如按行、按单词读取）。 第三阶段：动手实践（最重要的一步）现在，我们通过具体的代码来学习每个主角的用法。 1. bufio.Reader：更灵活的读取Reader 适合需要对读取过程有更多控制的场景，比如读取到特定分隔符为止。 创建方式: 123456789import ( &quot;bufio&quot; &quot;os&quot;)file, _ := os.Open(&quot;my_file.txt&quot;)defer file.Close()reader := bufio.NewReader(file) // 将一个 io.Reader 包装成 bufio.Reader 常用方法: ReadString(delim byte): 读取直到第一次遇到 delim 字节，返回一个包含 delim 的字符串。按行读取文本文件是它的经典用法。 ReadLine(): 一个更底层的按行读取方法，通常不推荐直接使用，ReadString('\\n') 或 Scanner 更好。 ReadByte(): 读取并返回一个字节。 Peek(n int): 非常酷的功能！ 它可以“偷看”接下来的 n 个字节，但不移动读取指针。也就是说，下次再读，还是从这 n 个字节开始。 实战代码：使用 ReadString 按行读取文件 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot; &quot;strings&quot;)func main() { // 准备一个字符串源，实际中可以是 os.File r := strings.NewReader(&quot;第一行\\n第二行\\n第三行&quot;) reader := bufio.NewReader(r) for { line, err := reader.ReadString('\\n') // 读取直到遇到换行符 if err == io.EOF { // io.EOF 表示文件已经读完 if len(line) &gt; 0 { fmt.Print(line) // 打印最后一行（可能没有换行符） } fmt.Println(&quot;文件读取完成&quot;) break } if err != nil { fmt.Println(&quot;读取文件时发生错误:&quot;, err) return } // ReadString 返回的行会包含分隔符本身，我们通常需要去掉它 fmt.Print(strings.TrimSpace(line)) fmt.Println(&quot; (已读取一行)&quot;) }} 2. bufio.Scanner：现代、简洁的文本读取利器对于按行、按单词读取文本这种常见需求，Scanner 是首选方案。它更简单、性能更好，并且能正确处理 \\n 和 \\r\\n 换行符。 创建方式: 1234567import &quot;bufio&quot;import &quot;os&quot;file, _ := os.Open(&quot;my_file.txt&quot;)defer file.Close()scanner := bufio.NewScanner(file) // 将一个 io.Reader 包装成 bufio.Scanner 常用方法: Scan() bool: 扫描到下一个“令牌”（默认是行），如果成功则返回 true。它通常用在 for 循环的条件里。 Text() string: 返回最近一次 Scan() 扫描到的令牌（行）的字符串内容。 Bytes() []byte: 功能同 Text()，但返回字节切片。 Err() error: 返回扫描过程中遇到的错误。 实战代码：使用 Scanner 按行读取文件（推荐方式） 12345678910111213141516171819202122232425package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)func main() { r := strings.NewReader(&quot;苹果\\n香蕉\\n橘子&quot;) scanner := bufio.NewScanner(r) // for scanner.Scan() 是 Go 中读取文本的惯用写法 (idiom) for scanner.Scan() { line := scanner.Text() // 获取当前行内容 fmt.Printf(&quot;扫描到一行: %s\\n&quot;, line) } // 扫描结束后，检查是否有错误发生 if err := scanner.Err(); err != nil { fmt.Println(&quot;扫描时发生错误:&quot;, err) }} 进阶: scanner.Split() 方法可以让你自定义分割规则，比如按单词、按逗号等。 3. bufio.Writer：高效写入Writer 的核心在于它的缓冲区。数据先写入内存，直到缓冲区满了或你手动“刷新”，才会真正写入底层的文件或网络连接。 创建方式: 1234567import &quot;bufio&quot;import &quot;os&quot;file, _ := os.Create(&quot;output.txt&quot;)defer file.Close()writer := bufio.NewWriter(file) 常用方法: WriteString(s string): 将字符串写入缓冲区。 Write(p []byte): 将字节切片写入缓冲区。 Flush(): 至关重要的方法！ 将缓冲区中所有的数据立刻写入底层的 io.Writer（例如文件）。忘记调用 Flush 是最常见的错误！ 实战代码：使用 Writer 高效写入文件 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() { file, err := os.Create(&quot;output.txt&quot;) if err != nil { panic(err) } defer file.Close() writer := bufio.NewWriter(file) // 写入几行字符串到缓冲区 _, _ = writer.WriteString(&quot;Hello, bufio!\\n&quot;) _, _ = writer.WriteString(&quot;这是第二行。\\n&quot;) fmt.Println(&quot;数据已写入缓冲区，但尚未写入文件。&quot;) // 此时打开 output.txt，你会发现文件是空的！ // 使用 Flush 将缓冲区内容写入文件 err = writer.Flush() if err != nil { panic(err) } fmt.Println(&quot;Flush() 已调用，数据已成功写入文件。&quot;) // 现在打开 output.txt，内容就在里面了。} 最佳实践: 使用 defer 来确保 Flush 总能被执行。 123456789func writeFile() { file, _ := os.Create(&quot;output.txt&quot;) defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() // &lt;--- 使用 defer 确保在函数退出前刷新缓冲区 writer.WriteString(&quot;这样写更安全！\\n&quot;)} 第四阶段：总结与选择 场景 推荐工具 为什么？ 按行/按单词读取文本文件 bufio.Scanner 代码最简洁、性能好、自动处理换行符，是首选。 需要读取到特定字符为止 bufio.Reader ReadString 方法完美匹配此需求。 需要**“偷看”**后面的数据而不移动指针 bufio.Reader 只有 Reader 提供 Peek 功能。 大量、频繁地写入小数据到文件或网络 bufio.Writer 显著提升写入性能，减少系统调用。 读取整个小文件 os.ReadFile 如果文件不大，一次性读入内存更简单，没必要用 bufio。 学习建议: 亲手把上面的每一段代码都敲一遍，并尝试修改它（比如换成真实的文件操作）。 理解 Flush 的重要性，并尝试不调用它看看会发生什么。 练习用 Scanner 读取标准输入 os.Stdin。 问题1总结来说，我只需要创建bufio.Reader: 带缓冲区的读取器。bufio.Writer: 带缓冲区的写入器。bufio.Scanner: 一个更高级、更方便的工具，用于读取结构化的文本数据（比如按行、按单词读取）。这三个东西，然后按照需求调用相应的函数就行了是吧 是的，你的总结非常精准！完全正确。 bufio 包的学习和使用核心，就是围绕这三个“主角”展开的。你可以把它们理解为你工具箱里三种不同但相关的工具： bufio.Reader (带缓冲区的读取器) 核心功能: 提供一个缓冲区来加速底层 io.Reader 的读取操作。 何时使用: 当你需要比 Scanner 更底层的控制时，比如： 读取到任意定的分隔符为止 (ReadString)。 需要“偷窥”数据流而不消耗它 (Peek)。 按特定字节数读取 (Read)。 bufio.Writer (带缓冲区的写入器) 核心功能: 提供一个缓冲区来加速底层 io.Writer 的写入操作。 何时使用: 当你需要向文件或网络连接进行大量、零碎的写入时。它能把这些零碎的写入合并成大的块，一次性发送，性能提升巨大。 必须记住: 用完一定要调用 Flush()，否则缓冲区的数据会丢失！最稳妥的方式是 defer writer.Flush()。 bufio.Scanner (高级文本扫描器) 核心功能: 专门用于读取结构化的文本数据。 何时使用: 这是处理文本文件最常用、最推荐的工具。 按行读取文件或标准输入（最常见的场景）。 按单词、逗号或其他自定义规则分割文本。 优点: 接口极其简洁（for scanner.Scan() 循环），性能好，自动处理各种换行符问题，不容易出错。 你的学习和使用流程就是： 明确你的 I/O 需求: “我要读取一个大文本文件，一行一行地处理。” -&gt; 选择 bufio.Scanner。 “我要向一个文件里循环写入上万条日志。” -&gt; 选择 bufio.Writer。 “我要从一个网络连接中读取数据，直到遇到一个特定的字节 0xFF 为止。” -&gt; 选择 bufio.Reader。 创建实例: 找到你的原始 io.Reader（如 os.File, strings.Reader, net.Conn）或 io.Writer。 调用 bufio.NewScanner(reader), bufio.NewReader(reader) 或 bufio.NewWriter(writer) 来“包装”它，得到一个带缓冲区的增强版工具。 调用方法: 根据你的具体需求，调用对应工具的方法（如 scanner.Scan(), reader.ReadString(), writer.WriteString()）。 收尾工作: 如果是 Writer，务必 Flush()。 如果是 Scanner，最好检查一下 scanner.Err()。 记得关闭底层的 io.Closer（如 file.Close()）。 所以，你完全掌握了 bufio 的精髓。剩下的就是在实际编码中多加练习，熟悉这三个工具的常用方法，你就能在 Go I/O 编程中游刃有余了。 问题2就是传入的东西，然后赋予的值，读取或者写入的角色我不是很清楚 你提出了一个非常关键的概念性问题，很多初学者都会在这里感到困惑。我们来彻底把它弄明白。 bufio 的所有工具（Reader, Writer, Scanner）都扮演着一个**“中间人”或者说“加工者”的角色。它们本身不是数据的来源或目的地，而是对数据的流动进行“增强”或“包装”**。 让我们用一个生动的比喻来解释：自来水系统。 数据源 (比如文件 os.File)：就像是市政供水管道。水（数据）在里面，但水压可能不稳定，开关一次成本很高（系统调用）。 bufio.Reader：就像是你家厨房水槽上的带蓄水池的净水器。 你的程序：就是你，想要接水喝。 1. bufio.Reader (带蓄水池的净水器)传入的东西: os.File (市政供水管道)赋予的值: bufio.Reader (带蓄水池的净水器)角色: 读取的角色 流程解释: reader := bufio.NewReader(file) 你做了什么：你把市政供水管道 (file) 接到了净水器 (bufio.Reader) 的进水口。 发生了什么：bufio.Reader 内部立刻从 file 里“猛吸”一大口水（比如4KB的数据）到自己的**蓄水池（缓冲区）**里，然后关上阀门。它只和市政管道交互了这一次，成本很低。 line, _ := reader.ReadString('\\n') 你做了什么：你按下了净水器上的“出水”按钮，想要接一杯水（一行数据）。 发生了什么：净水器直接从它自己的蓄水池里给你放水，直到遇到换行符。这个过程非常快，因为它操作的是内存里的蓄水池，根本没有去碰那个开关成本很高的市政管道。 如果蓄水池空了怎么办？：只有当蓄水池里的水不够你接一杯时，净水器才会再次打开阀门，从市政管道里再“猛吸”一大口水进来，然后再从新的蓄水池里给你放水。 总结 Reader 角色:它是一个带缓冲区的读取代理。你不再直接从原始、低效的数据源读取，而是从这个高效的、带“蓄水池”的代理那里读取。它负责在背后管理与原始数据源的交互，为你屏蔽了复杂性和低效性。 2. bufio.Writer (带储压罐的热水器)传入的东西: os.File (你家的排水管道)赋予的值: bufio.Writer (带储压罐的热水器)角色: 写入的角色 流程解释: writer := bufio.NewWriter(file) 你做了什么：你把热水器的出水口 (bufio.Writer) 接到了你家的排水管道 (file)。 发生了什么：bufio.Writer 准备好了自己的储压罐（缓冲区）。 writer.WriteString(&quot;一些话\\n&quot;) 你做了什么：你倒了一杯水（一些数据）到热水器的储压罐里。 发生了什么：这杯水只是进入了储压罐，并没有流进排水管道。因为每次都去打开排水管道的阀门成本太高了。 writer.Flush() 你做了什么：你按下了“冲洗/排空”按钮。 发生了什么：热水器打开阀门，一次性将储压罐里积攒的所有水，强力地冲入排水管道。这次交互虽然成本高，但我们只做了一次，而不是倒一杯水就冲一次。 总结 Writer 角色:它是一个带缓冲区的写入代理。你不再直接向原始、低效的目标写入，而是先把所有东西都“扔给”这个代理，它会帮你攒起来，最后在你需要的时候（或者攒满了的时候）一次性地、高效地写入最终目的地。 3. bufio.Scanner (智能饮水机)Scanner 是 Reader 的一个更高级、更自动化的版本，特别适合处理文本。 传入的东西: os.File (市政供水管道)赋予的值: bufio.Scanner (智能饮水机)角色: 一个更智能的读取角色 流程解释: scanner := bufio.NewScanner(file) 和 Reader 一样，你把市政管道 (file) 接到了智能饮水机 (bufio.Scanner)。它内部也有一个蓄水池（缓冲区），也会先猛吸一口水。 for scanner.Scan() 你做了什么：你不停地按“接一杯”按钮。 发生了什么：scanner.Scan() 会自动从蓄水池里帮你接好正好一杯（默认是一行）的水。如果成功接到，它就返回 true。你不需要关心它是怎么找到杯子边界（换行符）的，它都帮你处理好了。 line := scanner.Text() 你做了什么：你把刚刚接好的那杯水拿起来喝。 总结 Scanner 角色:它是一个自动化的、面向文本的读取助手。你只需要不断地告诉它“给我下一个”，它就会自动、高效地从原始数据源中把格式化好的数据（比如一行行的文本）递给你。 最终结论“传入的东西” (os.File, net.Conn等) 是原始的数据源或目的地。它们是底层、直接的 I/O 接口。 “赋予的值” (bufio.Reader, bufio.Writer等) 是一个带缓冲区的、高效的代理。 “角色”: bufio 的工具就是这个代理的角色。它夹在你和原始数据源之间，通过缓冲区这个核心机制，让你的数据读写变得更高效、更方便。你后续的所有 I/O 操作，都应该通过这个“代理”来进行，而不是再回头去操作原始的那个 file 对象。","link":"/2025/08/25/%E5%88%9D%E5%AD%A6bufio%E5%8C%85/"},{"title":"初学flag包","text":"flag 包是 Go 语言标准库中处理命令行参数的利器。学会它，你就能轻松地为你编写的命令行工具添加 -h、-version 等专业的参数功能。 第一阶段：理解核心思想 —— 什么是命令行标志 (Flag)？在学习代码之前，先理解概念。命令行标志（Flag）是程序运行时，在程序名后面跟的一些**“键值对”或“开关”**，用来改变程序的行为。 看一个我们熟悉的命令 ls： 1ls -l -h /home/user ls: 是程序名。 -l: 是一个布尔型 (bool) 标志。它就像一个开关，打开了“长列表格式”显示。 -h: 也是一个布尔型标志，打开了“人类可读的文件大小”显示。 /home/user: 这个不是标志，它是一个普通的命令行参数 (argument)。 flag 包就是专门用来定义和解析 -l 和 -h 这种带 - 或 -- 前缀的标志的。 核心思想： 定义 (Define)：在程序里预先声明你的程序接受哪些标志，它们是什么类型（字符串、整数、布尔值），以及它们的默认值和说明。 解析 (Parse)：在程序开始运行时，调用一个函数来解析用户在命令行实际传入了哪些标志和值。 使用 (Use)：在程序的后续逻辑中，像使用普通变量一样使用这些被解析出来的值。 第二阶段：掌握两种定义标志的方法flag 包提供了两种风格的定义方式，你需要都了解。 方法一：flag.String(), flag.Int(), flag.Bool() 等系列函数这种方法最常用，也最直接。它会返回一个指向解析值的指针。 函数签名格式:flag.Type(name string, defaultValue Type, usage string) *Type name: 标志的名字 (例如: “port”)。 defaultValue: 如果用户不提供这个标志，它会有的默认值。 usage: 标志的说明文字，当用户使用 -h 或 -help 时会显示。 返回值: 一个指向该类型值的指针。 实战代码 1: 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;flag&quot; &quot;fmt&quot;)func main() { // 1. 定义标志 // 定义一个名为 &quot;port&quot;，默认值为 8080 的整数标志 portPtr := flag.Int(&quot;port&quot;, 8080, &quot;设置服务监听的端口&quot;) // 定义一个名为 &quot;host&quot;，默认值为 &quot;localhost&quot; 的字符串标志 hostPtr := flag.String(&quot;host&quot;, &quot;localhost&quot;, &quot;设置服务监听的主机名&quot;) // 定义一个名为 &quot;debug&quot;，默认值为 false 的布尔标志 // 布尔标志有两种用法: -debug 或者 -debug=true debugPtr := flag.Bool(&quot;debug&quot;, false, &quot;开启调试模式&quot;) // 2. 解析标志 // 这一步至关重要！它会真正去读取 os.Args 来填充上面定义的指针 flag.Parse() // 3. 使用标志 // 因为返回的是指针，所以需要使用 * 来获取值 fmt.Printf(&quot;服务将运行在: %s:%d\\n&quot;, *hostPtr, *portPtr) if *debugPtr { fmt.Println(&quot;调试模式已开启！&quot;) } // flag.Args() 可以获取非标志的普通参数 fmt.Println(&quot;剩余的普通参数:&quot;, flag.Args())} 如何运行和测试这段代码: go build -o myapp 不带任何标志运行: ./myapp -&gt; 使用所有默认值。 提供标志: ./myapp -port=9090 -host=0.0.0.0 -debug 提供布尔标志的另一种方式: ./myapp -debug=true 查看帮助信息: ./myapp -h 或 ./myapp --help，你会看到你写的 usage 信息。 提供普通参数: ./myapp -port=3000 arg1 arg2 方法二：flag.StringVar(), flag.IntVar(), flag.BoolVar() 等系列函数这种方法允许你将解析的值绑定到一个已经存在的变量上。这在变量需要被多个函数共享时可能更方便。 函数签名格式:flag.TypeVar(p *Type, name string, defaultValue Type, usage string) p: 一个指向你提前定义好的变量的指针。 其他参数和方法一相同。 这个系列函数没有返回值。 实战代码 2 (功能同上): 1234567891011121314151617181920212223242526272829package mainimport ( &quot;flag&quot; &quot;fmt&quot;)// 提前定义好变量var port intvar host stringvar debug boolfunc main() { // 1. 定义标志并绑定到已有变量 // 注意第一个参数是变量的地址 (&amp;port) flag.IntVar(&amp;port, &quot;port&quot;, 8080, &quot;设置服务监听的端口&quot;) flag.StringVar(&amp;host, &quot;host&quot;, &quot;localhost&quot;, &quot;设置服务监听的主机名&quot;) flag.BoolVar(&amp;debug, &quot;debug&quot;, false, &quot;开启调试模式&quot;) // 2. 解析标志 flag.Parse() // 3. 使用标志 // 因为值是直接绑定到变量上的，所以直接使用变量名即可，无需 * fmt.Printf(&quot;服务将运行在: %s:%d\\n&quot;, host, port) if debug { fmt.Println(&quot;调试模式已开启！&quot;) }} 对比两种方法: 方法一（返回指针）更紧凑，定义和获取都在一个地方。 方法二（绑定变量）在变量需要是全局或在多个地方访问时，代码结构可能更清晰。 选择哪种主要看个人编码风格和具体场景，功能上没有优劣之分。初学者可以先熟练掌握第一种。 第三阶段：学习高级用法和最佳实践 自定义标志类型: flag.Var() 有时你需要处理更复杂的类型，比如一个逗号分隔的列表。你可以通过实现 flag.Value 接口来自定义标志类型。这是一个进阶话题，初学时可以先了解。 flag.Args() 和 flag.NArg() flag.Args(): 返回一个字符串切片 []string，包含所有非标志的命令行参数（就是那些前面没有 - 的参数）。 flag.NArg(): 返回非标志参数的数量，等同于 len(flag.Args())。 改变默认的帮助信息: flag.Usage flag.Usage 是一个变量，它的类型是 func()。你可以将它赋值为你自己的函数，来自定义 -h 时显示的帮助信息，比如加上程序的使用示例。 12345flag.Usage = func() { fmt.Fprintf(os.Stderr, &quot;用法: %s [选项] &lt;参数1&gt; &lt;参数2&gt;\\n&quot;, os.Args[0]) fmt.Fprintln(os.Stderr, &quot;选项:&quot;) flag.PrintDefaults() // 打印所有已定义的标志的默认说明} flag.Parse() 的位置 flag.Parse() 必须在所有标志都定义完成之后，并且在第一次使用任何标志的值之前被调用。通常把它放在 main 函数的开头部分。 FlagSet: 创建独立的标志集 默认情况下，所有的 flag.String, flag.Int 等函数都操作一个全局的标志集 flag.CommandLine。 如果你在编写一个复杂的程序，有多个子命令（比如 git commit, git push），每个子命令有自己不同的标志，这时你可以使用 flag.NewFlagSet 来为每个子命令创建独立的标志集。这是构建复杂命令行工具的关键。 学习路径总结 理解目的: flag 包是用来处理 -name=value 形式的命令行标志的。 掌握基础: 熟练使用 flag.String(), flag.Int(), flag.Bool() 这三个函数。记住定义、解析、使用的三步流程。 动手实践: 编写一个小工具，用 flag 添加配置项，并通过命令行改变它的行为。 了解进阶: 知道 flag.Args() 是用来获取非标志参数的，以及 flag.Usage 可以自定义帮助信息。 展望未来: 当你需要构建类似 docker 或 kubectl 这样的多子命令工具时，再去深入研究 FlagSet。 通过这个路径，你就能扎实地掌握 flag 包，并为你未来的 Go 程序编写出专业、易用的命令行接口。","link":"/2025/08/25/%E5%88%9D%E5%AD%A6flag%E5%8C%85/"},{"title":"初学go_web记录1","text":"问题1：r.ParseForm() 不是有这个才能读取到请求头里面的东西吗，怎么login里面开始就读取了r.method你提出了一个非常好的问题，这能帮助我们更精确地区分 http.Request 对象中不同部分的访问方式。 答案是：r.Method 和 r.ParseForm() 处理的是请求中完全不同的两个部分，它们互不依赖。 让我们把一个 HTTP 请求想象成一个快递包裹： r.Method, r.URL, r.Header 等: 这些信息就像写在快递包裹外面的“运单”。运单上有发件人、收件人地址、包裹类型（普通/加急）等信息。你不需要打开包裹就能直接读取这些信息。 r.Form, r.PostForm, r.MultipartForm: 这些信息是包裹内部装的东西，特别是当包裹里是一个填好的“订单”（HTML 表单数据）时。你需要一个专门的动作——“拆开包裹并整理订单内容”——才能读取这些信息。这个动作就是 r.ParseForm()。 r.Method 是什么？ r.Method 存储的是 HTTP 请求的方法 (Method)，例如 GET, POST, PUT, DELETE 等。 这个信息位于 HTTP 请求报文的起始行 (Request Line)，是整个请求最开始、最基本的部分。 当 Go 的 net/http 服务器接收到一个请求时，它会最先解析这部分内容，因为它需要根据请求方法和 URL 来决定如何处理这个请求。 因此，r.Method 的值在 http.Handler 函数被调用时就已经被解析好并填充到 r 对象里了。你随时都可以直接访问它，完全不需要调用 r.ParseForm()。 一个简化的 HTTP GET 请求报文示例: 1234GET /login HTTP/1.1 &lt;-- r.Method 就在这里 (起始行)Host: localhost:9090 &lt;-- r.Host 和 r.Header 的一部分User-Agent: curl/7.64.1Accept: */* r.ParseForm() 是做什么的？r.ParseForm() 的作用是解析请求中和表单数据相关的部分。具体来说，它会做两件事： 对于 GET 请求: 它会解析 URL 中的查询字符串 (Query String)。 例如，对于 URL http://.../login?username=alice&amp;lang=en，r.ParseForm() 会把 username 和 lang 这两个键值对解析出来，放到 r.Form 这个 map 里。 对于 POST 或 PUT 请求: 它会解析请求体 (Request Body)。 前提是请求的 Content-Type 是 application/x-www-form-urlencoded 或 multipart/form-data。 它会读取请求体的内容，解析出里面的键值对（例如 username=bob&amp;password=123），然后把它们也放到 r.Form 里。 关键点: 这是一个有成本的操作，因为它可能需要读取和解析整个请求体，这会消耗时间和内存。 因此，Go 的设计者决定让这个操作**“按需执行”**。只有当你真正需要访问表单数据（r.Form, r.PostForm）时，才需要手动调用一次 r.ParseForm()。 如果你不调用 r.ParseForm() 就尝试访问 r.Form，r.Form 会是空的 (nil)。 总结与代码中的体现在你的 login 函数中： 1234567891011121314151617181920212223func login(w http.ResponseWriter, r *http.Request) { // 1. 直接访问请求的 &quot;运单&quot; 信息，无需 ParseForm fmt.Println(&quot;method:&quot;, r.Method) // 2. 根据 &quot;运单&quot; 上的方法，决定下一步做什么 if r.Method == &quot;GET&quot; { // GET 请求，通常没有请求体，我们只是显示一个页面，不需要 ParseForm t, _ := template.ParseFiles(&quot;login.gtpl&quot;) log.Println(t.Execute(w, nil)) } else { // 假设是 POST // POST 请求，我们需要 &quot;拆开包裹&quot; 读取里面的表单数据 // 所以在这里，调用 ParseForm 是必须的 err := r.ParseForm() if err != nil { log.Fatal(&quot;ParseForm: &quot;, err) } // 3. 现在可以安全地访问 &quot;包裹&quot; 里的内容了 fmt.Println(&quot;username:&quot;, r.Form[&quot;username&quot;]) fmt.Println(&quot;password:&quot;, r.Form[&quot;password&quot;]) }} 结论： 读取请求的元数据（如 Method, URL, Header, Host），不需要 r.ParseForm()。 读取请求的表单数据（URL 查询参数或 POST 请求体），必须先调用 r.ParseForm()。 问题2:请用具体真实的例子解释一下好的，没问题！我们用一个非常具体、真实的例子来彻底拆解一个 HTTP 请求，看看它的各个部分都对应 r 对象的哪些字段，以及哪些需要 ParseForm。 场景：用户在浏览器中提交登录表单假设我们的登录页面 (login.gtpl) 是这样的： 12345&lt;form action=&quot;/login?source=web&quot; method=&quot;post&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt; action=&quot;/login?source=web&quot;: 表单将提交到 /login 路径，并且 URL 里还带了一个查询参数 source=web。 method=&quot;post&quot;: 使用 POST 方法提交。 用户在表单里输入了： Username: cofeesy Password: 123456 然后点击了 “Login” 按钮。 第一步：浏览器生成 HTTP 请求浏览器会根据用户的操作，生成一段类似下面这样的原始文本数据，然后通过网络发送给你的 Go 服务器。这就是一个真实的 HTTP 请求报文 (HTTP Request Message)： 123456POST /login?source=web HTTP/1.1Host: 127.0.0.1:9090Content-Type: application/x-www-form-urlencodedContent-Length: 32username=cofeesy&amp;password=123456 第二步：Go 服务器解析请求当你的 Go 服务器收到这段文本后，net/http 包会像一个“解码器”一样，自动地、在调用你的 login 函数之前，解析其中的一部分，并填充到 r *http.Request 对象里。 我们来逐行看看这段报文被解析成了什么，以及哪些不需要 ParseForm() 就能直接读取。 1. 起始行 (Start Line)1POST /login?source=web HTTP/1.1 这是请求的最核心部分，包含了三块信息。Go 服务器会立刻解析它： POST: 这是请求方法。 对应代码: r.Method 值: &quot;POST&quot; 是否需要 ParseForm(): 否。这是最先被解析的，可以直接读。 /login?source=web: 这是请求的 URI。Go 会把它进一步拆分： 对应代码: r.URL.Path -&gt; /login r.URL.RawQuery -&gt; source=web 是否需要 ParseForm(): 否。URL 是路由的基础，必须先解析，可以直接读。 HTTP/1.1: 这是协议版本。 对应代码: r.Proto 值: &quot;HTTP/1.1&quot; 是否需要 ParseForm(): 否。 2. 请求头 (Headers)123Host: 127.0.0.1:9090Content-Type: application/x-www-form-urlencodedContent-Length: 32 这些是键值对，提供了关于请求的元数据。 对应代码: r.Header (这是一个 map[string][]string) r.Header.Get(&quot;Content-Type&quot;) -&gt; &quot;application/x-www-form-urlencoded&quot; r.Host 是一个方便访问 Host 头的快捷字段，值为 &quot;127.0.0.1:9090&quot; 是否需要 ParseForm(): 否。请求头是紧跟在起始行后面的，也会被立即解析。 第三步：login 函数被调用，ParseForm 登场到现在为止，你的 login 函数已经被调用，并且 r 对象里已经填满了上述所有信息。但还有一部分数据，Go 服务器没有碰，因为它不知道你是否需要它，也不确定它是什么格式。 3. 请求体 (Request Body)12(一个空行)username=cofeesy&amp;password=123456 这部分数据就是我们说的“包裹里的东西”。 对应代码: 原始数据流：r.Body (这是一个 io.ReadCloser) 解析后的数据：r.Form 和 r.PostForm 为什么需要 ParseForm()： r.Body 可能非常大（比如上传一个几GB的文件），服务器不会自动读取并解析它，因为这可能耗尽内存。 只有当你调用 r.ParseForm() 时，Go 才会根据请求头里的 Content-Type（application/x-www-form-urlencoded），去读取 r.Body 的数据流，并按照指定的格式（key=value&amp;key2=value2）进行解析。 解析完成后，它会把结果 username=cofeesy 和 password=123456 填充到 r.PostForm 这个 map 里。 关于 r.Form 的一个细节： r.ParseForm() 不仅解析请求体，它还会顺便把 URL 里的查询参数（source=web）也解析了。 最终，r.Form 会是URL 查询参数和POST 表单数据的合集。 r.PostForm 只包含 POST 表单数据。 所以，在你的 login 函数里： 1234567891011121314151617func login(w http.ResponseWriter, r *http.Request) { // 在这里，r.Method, r.URL.Path 等已经有值了 // ... // 如果不调用下面这行 // r.ParseForm() // 那么 r.Form[&quot;username&quot;] 的值将会是 nil 或空 // 只有调用了 r.ParseForm() 之后... r.ParseForm() // 下面的代码才能取到值 fmt.Println(r.FormValue(&quot;username&quot;)) // &quot;cofeesy&quot; fmt.Println(r.FormValue(&quot;source&quot;)) // &quot;web&quot;} 总结 请求的部分 对应 r 中的字段/方法 何时被解析 是否需要 r.ParseForm() 请求方法 (POST) r.Method 自动，在处理函数调用前 否 URL路径 (/login) r.URL.Path 自动，在处理函数调用前 否 请求头 (Host, …) r.Header, r.Host 自动，在处理函数调用前 否 URL查询参数 (?source=web) r.URL.RawQuery (原始), r.Form (解析后) 按需，在调用 ParseForm 时 是 请求体 (username=…) r.Body (原始), r.PostForm, r.Form (解析后) 按需，在调用 ParseForm 时 是","link":"/2025/08/27/%E5%88%9D%E5%AD%A6go-web%E8%AE%B0%E5%BD%951/"},{"title":"数据库-简单操作步骤学习01","text":"问题：为什么改和增加需要先prepare，然后根据返回的stmt状态在exec中传参，而查询就直接用了数据库的指针进行query呢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( &quot;database/sql&quot; &quot;fmt&quot; // &quot;time&quot; _ &quot;github.com/go-sql-driver/mysql&quot;)func main() { db, err := sql.Open(&quot;mysql&quot;, &quot;astaxie:astaxie@/test?charset=utf8&quot;) checkErr(err) // 插入数据 stmt, err := db.Prepare(&quot;INSERT userinfo SET username=?,department=?,created=?&quot;) checkErr(err) res, err := stmt.Exec(&quot;astaxie&quot;, &quot;研发部门&quot;, &quot;2012-12-09&quot;) checkErr(err) id, err := res.LastInsertId() checkErr(err) fmt.Println(id) // 更新数据 stmt, err = db.Prepare(&quot;update userinfo set username=? where uid=?&quot;) checkErr(err) res, err = stmt.Exec(&quot;astaxieupdate&quot;, id) checkErr(err) affect, err := res.RowsAffected() checkErr(err) fmt.Println(affect) // 查询数据 rows, err := db.Query(&quot;SELECT * FROM userinfo&quot;) checkErr(err) for rows.Next() { var uid int var username string var department string var created string err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created) checkErr(err) fmt.Println(uid) fmt.Println(username) fmt.Println(department) fmt.Println(created) } // 删除数据 stmt, err = db.Prepare(&quot;delete from userinfo where uid=?&quot;) checkErr(err) res, err = stmt.Exec(id) checkErr(err) affect, err = res.RowsAffected() checkErr(err) fmt.Println(affect) db.Close()}func checkErr(err error) { if err != nil { panic(err) }} 你提出了一个关于 Go database/sql 包设计的非常深刻且关键的问题！为什么增删改（写操作）推荐 Prepare -&gt; Exec，而查询（读操作）可以直接 Query？ 答案涉及到性能、安全和代码清晰度三个方面。 简单来说： Prepare 是一种数据库的“预编译”优化。对于需要重复执行的 SQL 语句，它能带来巨大的性能提升。增删改操作往往是重复性很高的。 Query 也可以 Prepare，但很多查询只执行一次，直接 db.Query 更方便。 无论是写操作还是读操作，都应该优先考虑使用 Prepare，这是一种更安全、更高效的最佳实践。 db.Prepare 到底做了什么？当你调用 stmt, err := db.Prepare(&quot;INSERT ... username=?, ...&quot;) 时，database/sql 包会和数据库进行一次通信，发生以下事情： 发送 SQL 模板: Go 会把你的 SQL 语句模板（包含 ? 占位符，但没有具体的值）发送给数据库服务器（比如 MySQL）。 数据库预编译: 数据库收到这个模板后，会对其进行： 语法分析: 检查 SQL 语法是否正确。 语义分析: 检查表名、字段名是否存在。 生成执行计划: 数据库优化器会分析如何最高效地执行这条 SQL（比如用哪个索引），并把这个“执行计划”缓存起来。 返回一个“凭证”: 数据库告诉 Go：“好的，这个 SQL 模板我已经准备好了，以后你只要拿着这个‘凭证’（stmt 对象），带着参数来就行，不用每次都把整个 SQL 语句发给我了。” 这个 stmt (sql.Stmt) 对象，就是那个预编译好的 SQL 语句的句柄或“凭证”。 stmt.Exec() 或 stmt.Query() 做了什么？当你调用 res, err := stmt.Exec(&quot;astaxie&quot;, &quot;研发部门&quot;, ...) 时： 发送“凭证”和参数: Go 只需要把那个很小的“凭证” (stmt) 和需要填入 ? 的具体参数值发送给数据库。 数据库执行: 数据库拿到凭证，立刻找到之前缓存好的执行计划，然后把参数安全地填进去执行。这个过程跳过了耗时的语法分析和生成执行计划的步骤。 现在来回答你的问题：为什么增删改“需要” Prepare？1. 性能优势 (最重要的原因) 增删改操作通常是高度重复的。想象一个网站的用户注册功能，INSERT userinfo SET ... 这条 SQL 语句的结构是完全不变的，只是每次传入的用户名、部门、创建时间不同。 在这种场景下，你可以在程序初始化时只 Prepare 一次，得到一个 stmt 对象，然后在每次用户注册时都复用这个 stmt 对象来 Exec。 收益: 避免了成千上万次的 SQL 解析和执行计划生成，极大地减轻了数据库的负担，提升了应用的性能。 2. 安全优势 (防止 SQL 注入) Prepare + Exec 这种使用占位符 ? 的方式，是防止 SQL 注入攻击的标准方法。 当你使用 ? 时，你发送给数据库的是“SQL模板”和“参数数据”两个独立的东西。数据库会确保“参数数据”永远只被当作数据来处理，绝不会被当作 SQL 代码的一部分来执行。 注意: 这一点对于 db.Query 和 db.Exec 直接传参也是一样的。只要你使用 ? 占位符，而不是用字符串拼接来构造 SQL，就是安全的。 但 Prepare 的模式天然地鼓励了这种安全的写法。 那么，为什么查询可以直接 db.Query？你的代码里是这样写的： 1rows, err := db.Query(&quot;SELECT * FROM userinfo&quot;) 这里没有参数，所以很直接。我们看一个带参数的例子： 1rows, err := db.Query(&quot;SELECT * FROM userinfo WHERE uid=?&quot;, id) db.Query() 和 db.Exec() 其实是 Prepare + Query/Exec + Close 的一个便捷封装。 当你直接调用 db.Query(&quot;SELECT ... uid=?&quot;, id) 时，database/sql 包在内部隐式地为你做了类似的事情： 它可能在内部 Prepare 这条 SQL。 然后用你的参数 id 去 Exec 或 Query。 然后立即关闭这个 stmt。 为什么提供这个便捷方式？ 方便性: 很多查询在程序中可能只会出现一次，或者每次查询的 SQL 结构都不一样（比如动态构建的复杂查询）。在这种情况下，Prepare 带来的性能优势不大（因为只执行一次），而每次都写 Prepare -&gt; Query -&gt; Close 会显得很繁琐。 所以，db.Query 提供了一个方便的快捷方式，适合那些一次性或不常重复的查询。 最佳实践是什么？ 对于任何需要重复执行的 SQL 语句（无论是增删改还是查），都应该使用 db.Prepare()。 这是最高效、最规范的写法。你应该在应用的关键路径上（比如高频的 API 调用中）坚持这样做。 12345678// 在服务初始化时 Preparevar insertStmt *sql.StmtinsertStmt, err = db.Prepare(&quot;INSERT ...&quot;)// 在处理请求的函数中复用func handleRequest() { insertStmt.Exec(...)} 对于那些只执行一次、或者很少执行的、或者 SQL 语句动态变化的查询，使用 db.Query() 或 db.QueryRow() 作为快捷方式是完全可以的。 总结一下你的代码： 你代码中对增删改使用 Prepare 的方式是非常正确和值得提倡的。 你对查询使用 db.Query 也是可以的，因为它简单直接。但如果你知道这个查询会被频繁调用，那么把它也改成 Prepare 的模式会获得更好的性能。 你通过观察代码发现了 database/sql 包设计的细微差别，这说明你思考得非常深入！","link":"/2025/08/28/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%AD%A6%E4%B9%A001/"},{"title":"驱动导入","text":"问题_ “github.com/go-sql-driver/mysql”,前面的_有什么用你问到了 Go 语言中一个非常独特且重要的语法特性！ import 语句前面的 _ (下划线，也叫空白标识符 Blank Identifier) 的作用是： 执行该包的初始化代码，但是不直接使用该包中的任何导出函数或变量。 让我们来详细分解一下这个概念。 Go 包的初始化 init() 函数在 Go 语言中，每个包都可以包含一个或多个 init() 函数。这些函数非常特殊： 自动执行: 当一个包被导入时，它的 init() 函数会在 main() 函数执行之前被 Go 运行时自动调用。 无需调用: 你不能手动调用 init() 函数，它是由 Go 的程序加载机制来管理的。 主要用途: init() 函数通常用于执行一些一次性的初始化任务，比如： 设置包级别的变量。 校验配置。 最重要的：向某个“注册中心”注册自己。 _ &quot;github.com/go-sql-driver/mysql&quot; 的具体场景现在我们来看你代码中的例子。这行代码在 Go 的数据库编程中几乎是标准写法。 database/sql 包的设计 Go 的标准库 database/sql 提供了一套通用的、与具体数据库无关的 SQL 操作接口。它定义了像 sql.DB, sql.Rows, sql.Stmt 这样的类型，以及 sql.Open(), db.Query() 等函数和方法。 但是，database/sql 包本身并不知道如何去连接和操作任何一种具体的数据库（比如 MySQL, PostgreSQL, SQLite）。它就像一个“插座标准”，定义了插头的形状，但它本身不生产电器。 数据库驱动 (Driver) 的角色 像 github.com/go-sql-driver/mysql 这样的包，就是一个具体的数据库驱动。它就像一个“符合标准的电器插头”。它的职责是： 实现 database/sql 包中定义的那些底层接口。 知道如何通过网络协议与 MySQL 数据库进行通信。 将自己的功能“注册”到 database/sql 包中。 init() 函数的魔力 在 github.com/go-sql-driver/mysql 包的源码中，你一定会找到一个 init() 函数，它的核心逻辑大致如下（伪代码）： 123456789101112// in package mysqlimport &quot;database/sql&quot;func init() { // 创建一个实现了 database/sql 接口的 mysqlDriver 对象 driver := &amp;mysqlDriver{} // 调用 database/sql 包提供的 Register 函数， // 把自己以 &quot;mysql&quot; 这个名字注册进去。 sql.Register(&quot;mysql&quot;, driver) } 这个 init() 函数就是这个驱动包的“自我介绍信”。当这个包被导入时，它会立刻执行 init()，跑到 database/sql 这个“总登记处”说：“你好，我叫 mysql，我知道怎么和 MySQL 数据库打交道。以后有人要用 mysql，就来找我。” 为什么用 _？Go 编译器有一个严格的规则：如果你导入了一个包，就必须在代码中至少使用一次该包导出的成员（变量、函数、类型等）。如果只导入不使用，编译器会报错。 在我们的数据库例子中： 我们确实需要 mysql 驱动包执行它的 init() 函数来完成注册。 但是，在我们的主代码逻辑中，我们不会直接调用任何 mysql 包里的函数（比如 mysql.Connect() 之类的）。我们所有的数据库操作都是通过通用的 database/sql 包来进行的。 12// 我们用的是 sql.Open，而不是 mysql.Opendb, err := sql.Open(&quot;mysql&quot;, &quot;user:password@/dbname&quot;) 当 sql.Open 被调用时，它会查看第一个参数 &quot;mysql&quot;，然后在自己的“登记表”里查找：“谁注册了 mysql 这个名字？”。哦，是 github.com/go-sql-driver/mysql 那个驱动！然后 sql.Open 就会使用这个已经注册好的驱动去建立连接。 所以 _ 的作用就是： 告诉编译器：“我知道我没有直接使用这个包里的任何东西，但请你不要报错。” 同时，Go 的运行时仍然会加载这个包，从而触发其 init() 函数的执行。 我们称这种导入方式为**“为副作用而导入 (import for side effect)”**。这个“副作用”就是执行包的 init() 函数。 总结：_ &quot;github.com/go-sql-driver/mysql&quot; 是一条指令，意思是：“请加载并执行 mysql 驱动包的初始化代码，让它向 database/sql 注册自己。我保证我不会在代码里直接调用这个包的任何东西，所以请编译器不要因为‘未使用导入’而报错。”","link":"/2025/08/28/%E9%A9%B1%E5%8A%A8%E5%AF%BC%E5%85%A5/"},{"title":"服务器免密登陆","text":"配置 SSH 免密登录（Mac）这个方案的原理是：你在你的 Mac 电脑上生成一对“密钥”（一个公钥，一个私钥），然后把“公钥”（相当于一把锁）放到远程服务器上你账户的“钥匙串”里。之后，你每次用 scp 或 ssh 连接时，你的电脑会自动用“私钥”（你的钥匙）去开服务器上的那把锁，整个过程无需输入密码。 操作步骤 (只需要做一次)： 检查是否已有 SSH 密钥打开终端，输入： 1ls -l ~/.ssh/id_rsa.pub 如果显示文件存在，说明你已经有密钥了，可以跳到第 3 步。 如果提示 No such file or directory，你需要先生成一对密钥。 生成新的 SSH 密钥 (如果需要) 1ssh-keygen -t rsa -b 4096 它会提示你保存文件的位置，直接按回车（默认是 ~/.ssh/id_rsa）。 它会提示你输入 passphrase (密码短语)，为了方便自动化，直接按回车，留空即可。再按一次回车确认。 执行完毕后，~/.ssh/ 目录下就会生成 id_rsa (私钥) 和 id_rsa.pub (公钥)。 将你的公钥复制到远程服务器这有一条非常方便的命令 ssh-copy-id 来自动完成这件事。请注意，这条命令需要你指定正确的端口号。 1ssh-copy-id username@ip 这条命令会提示你输入一次用户的密码。这是最后一次你需要为这个连接输入密码了。 它会自动把你的公钥 (~/.ssh/id_rsa.pub 的内容) 追加到远程服务器的 ~/.ssh/authorized_keys 文件中。","link":"/2025/08/29/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/"}],"tags":[{"name":"Goland","slug":"Goland","link":"/tags/Goland/"}],"categories":[],"pages":[]}