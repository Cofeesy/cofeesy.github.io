{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/08/17/hello-world/"},{"title":"位掩码的魔力","text":"Go log.SetFlags：为何它能用 | 合并参数？秒懂位掩码的魔力在使用 Go 语言进行开发时，标准库 log 是我们打交道的老朋友了。也许你曾无数次地写下或看到过下面这行熟悉的代码： 123456import &quot;log&quot;func main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(&quot;这是一条日志消息。&quot;)} 运行后，你会得到类似这样的输出： 12025/08/25 15:27:02.885249 /Users/cofeesy_zzz/Documents/go_project/my_demo/main.go:129: 这是一条日志消息。 代码运行得完美无瑕，但你是否曾停下来，对 log.Llongfile | log.Lmicroseconds | log.Ldate 这部分代码产生过一丝好奇？ SetFlags 函数的签名明明是 func SetFlags(flag int)，它只接受一个 int 类型的参数。我们为什么可以用 |（竖线）将好几个常量“连接”起来，看起来就像魔法一样传入了多个选项呢？ 这背后并没有魔法，而是一个在计算机科学中广泛使用、既经典又高效的编程技巧——位掩码（Bitmask）。 今天，就让我们一起揭开它的神秘面纱！ 第一步：| 不是普通的“或”首先，我们需要明确一点：这里的 | 并不是我们在 if 语句中常见的逻辑或 ||，也不是某个特殊的分隔符。它是一个位运算符，学名叫“按位或（Bitwise OR）”。 它的工作原理非常简单：将两个数字转换为二进制，然后逐位进行比较。只要对应位上有一个是 1，结果的对应位就是 1。 举个例子，计算 5 | 3： 将 5 和 3 转换为二进制： 5 = 0101 3 = 0011 逐位进行“或”运算： 1234 0101 (5)| 0011 (3)--------- 0111 (7) 所以，5 | 3 的结果是 7。 | 操作符是解开谜题的钥匙，但真正让这把钥匙能开锁的，是那些 log 常量的巧妙设计。 第二步：藏在常量里的“秘密”让我们深入 log 包的源码，看看这些常量的定义： 123456789// From src/log/log.goconst ( Ldate = 1 &lt;&lt; iota // the date in the local time zone: 2009/01/23 Ltime = 1 &lt;&lt; iota // the time in the local time zone: 01:23:23 Lmicroseconds = 1 &lt;&lt; iota // microsecond resolution: 01:23:23.123123. Llongfile = 1 &lt;&lt; iota // full file name and line number: /a/b/c/d.go:23 Lshortfile = 1 &lt;&lt; iota // final file name element and line number: d.go:23 // ...) 这里的 iota 是 Go 语言中一个神奇的常量计数器，默认从 0 开始。而 &lt;&lt; 是左移位运算符。1 &lt;&lt; iota 的意思就是将数字 1 的二进制表示向左移动 iota 位。 让我们把这些常量的值算出来，看看它们的二进制形式： 常量名 计算过程 十进制值 二进制表示 Ldate 1 &lt;&lt; 0 1 0000 0001 Ltime 1 &lt;&lt; 1 2 0000 0010 Lmicroseconds 1 &lt;&lt; 2 4 0000 0100 Llongfile 1 &lt;&lt; 3 8 0000 1000 Lshortfile 1 &lt;&lt; 4 16 0001 0000 发现规律了吗？ 每个常量在二进制形式下，都只有一个位是 1，并且这个 1 所在的位置是独一无二、互不冲突的！ 第三步：开关面板的比喻现在，让我们用一个生动的比喻来理解这一切。 想象一个 int 整数就是一个拥有 32 个（或 64 个）灯泡的开关面板。每个灯泡的位置（即二进制位）都代表一个特定的功能。 Ldate 的值是 1 (...0001)，它代表“打开最右边第 1 个灯泡”的指令。 Lmicroseconds 的值是 4 (...0100)，它代表“打开从右数第 3 个灯泡”的指令。 Llongfile 的值是 8 (...1000)，它代表“打开从右数第 4 个灯泡”的指令。 而我们使用的 |（按位或）操作，就相当于同时按下这几个开关！ 当我们执行 log.Llongfile | log.Lmicroseconds | log.Ldate 时，计算机内部发生了： 12345 0000 1000 (Llongfile: 打开第4个灯)| 0000 0100 (Lmicroseconds: 打开第3个灯)| 0000 0001 (Ldate: 打开第1个灯)------------------ 0000 1101 (最终状态) 这个结果 0000 1101（十进制为 13），就是一个包含了所有选项信息的单一整数。它像一张状态快照，完美地记录了“第1、3、4号灯泡都亮着”这个事实。 所以，log.SetFlags(...) 这行代码，最终只向函数传递了一个 int 值：13。 第四步：函数内部如何“读懂”你好了，SetFlags 函数收到了整数 13。它又是如何知道我们要的是“日期”、“微秒”和“长文件名”这三个选项呢？ 答案是另一个位运算符：&amp;（按位与，Bitwise AND）。 &amp; 的规则是：两个二进制数的对应位，只有都是 1，结果的对应位才是 1，否则为 0。 SetFlags 函数内部会用收到的参数 flag 和每一个常量进行 &amp; 运算，来检查对应的“开关”是否打开： 12345678910111213141516171819202122// 函数内部逻辑的伪代码演示func (l *Logger) SetFlags(flag int) { // 检查是否需要显示日期 // 13 &amp; 1 -&gt; (0000 1101 &amp; 0000 0001) -&gt; 0000 0001 (结果不为0) if (flag &amp; Ldate) != 0 { // 条件成立！开启显示日期的功能 } // 检查是否需要显示时间 // 13 &amp; 2 -&gt; (0000 1101 &amp; 0000 0010) -&gt; 0000 0000 (结果为0) if (flag &amp; Ltime) != 0 { // 条件不成立，跳过 } // 检查是否需要显示微秒 // 13 &amp; 4 -&gt; (0000 1101 &amp; 0000 0100) -&gt; 0000 0100 (结果不为0) if (flag &amp; Lmicroseconds) != 0 { // 条件成立！开启显示微秒的功能 } // ... 以此类推} 通过这种方式，函数就能精确地解析出我们通过 | 组合起来的所有选项。 总结：为何要使用位掩码？位掩码是一种非常优雅的编程技巧，它的优点显而易见： 高效性：用一个整数就可以打包传递多个布尔型的选项，极大地节省了空间，也让函数调用更简洁。 可扩展性：如果未来 log 包想增加一个新的日志选项，只需定义一个新的、二进制位不冲突的常量即可，完全不会影响现有的函数签名和代码。 可读性：相比于 SetOptions(true, false, true, true) 这样的长串布尔参数，OptA | OptB | OptC 的写法显然更清晰，意图也更明确。 这种技巧在各种编程场景中都屡见不鲜，例如 Linux/Unix 系统的文件权限（rwx -&gt; 421），各种图形库的渲染标志，以及网络协议的控制位等等。 现在，当你再次看到 flag1 | flag2 这样的代码时，希望你脑海中浮现的不再是神秘的符号，而是一块清晰明了、亮着不同灯光的二进制开关面板。这，就是位掩码的魅力所在！","link":"/2025/08/25/%E4%BD%8D%E6%8E%A9%E7%A0%81%E7%9A%84%E9%AD%94%E5%8A%9B/"},{"title":"初学bufio包","text":"第一阶段：理解核心思想 —— 为什么要用 bufio？在直接看代码之前，你必须先理解 bufio 存在的根本原因：减少系统调用，提升 I/O 性能。 想象一下你要从超市（磁盘）买100件商品（数据）。你有两种方式： 不用 bufio: 每次只拿一件商品，然后去收银台结账，来回100次。结账这个动作就像一次“系统调用（System Call）”，非常耗时。 使用 bufio: 你推一个购物车（缓冲区 Buffer），先把100件商品都放进购物车里，最后只去收银台结账一次。 bufio 包就是这个“购物车”。它在内存中开辟一块缓冲区，当你读取数据时，它会一次性从磁盘（或网络）读取一大块数据到缓冲区；当你写入数据时，它会先把数据写入缓冲区，等缓冲区满了或者你主动要求时，才一次性写入磁盘。 核心结论: bufio 通过在内存中增加一个缓冲区，将多次零散的 I/O 操作合并为单次或少数几次大的 I/O 操作，从而显著提高性能。 第二阶段：认识三大主角bufio 包主要提供了三个非常有用的类型，你需要分别了解它们： bufio.Reader: 带缓冲区的读取器。 bufio.Writer: 带缓冲区的写入器。 bufio.Scanner: 一个更高级、更方便的工具，用于读取结构化的文本数据（比如按行、按单词读取）。 第三阶段：动手实践（最重要的一步）现在，我们通过具体的代码来学习每个主角的用法。 1. bufio.Reader：更灵活的读取Reader 适合需要对读取过程有更多控制的场景，比如读取到特定分隔符为止。 创建方式: 123456789import ( &quot;bufio&quot; &quot;os&quot;)file, _ := os.Open(&quot;my_file.txt&quot;)defer file.Close()reader := bufio.NewReader(file) // 将一个 io.Reader 包装成 bufio.Reader 常用方法: ReadString(delim byte): 读取直到第一次遇到 delim 字节，返回一个包含 delim 的字符串。按行读取文本文件是它的经典用法。 ReadLine(): 一个更底层的按行读取方法，通常不推荐直接使用，ReadString('\\n') 或 Scanner 更好。 ReadByte(): 读取并返回一个字节。 Peek(n int): 非常酷的功能！ 它可以“偷看”接下来的 n 个字节，但不移动读取指针。也就是说，下次再读，还是从这 n 个字节开始。 实战代码：使用 ReadString 按行读取文件 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;os&quot; &quot;strings&quot;)func main() { // 准备一个字符串源，实际中可以是 os.File r := strings.NewReader(&quot;第一行\\n第二行\\n第三行&quot;) reader := bufio.NewReader(r) for { line, err := reader.ReadString('\\n') // 读取直到遇到换行符 if err == io.EOF { // io.EOF 表示文件已经读完 if len(line) &gt; 0 { fmt.Print(line) // 打印最后一行（可能没有换行符） } fmt.Println(&quot;文件读取完成&quot;) break } if err != nil { fmt.Println(&quot;读取文件时发生错误:&quot;, err) return } // ReadString 返回的行会包含分隔符本身，我们通常需要去掉它 fmt.Print(strings.TrimSpace(line)) fmt.Println(&quot; (已读取一行)&quot;) }} 2. bufio.Scanner：现代、简洁的文本读取利器对于按行、按单词读取文本这种常见需求，Scanner 是首选方案。它更简单、性能更好，并且能正确处理 \\n 和 \\r\\n 换行符。 创建方式: 1234567import &quot;bufio&quot;import &quot;os&quot;file, _ := os.Open(&quot;my_file.txt&quot;)defer file.Close()scanner := bufio.NewScanner(file) // 将一个 io.Reader 包装成 bufio.Scanner 常用方法: Scan() bool: 扫描到下一个“令牌”（默认是行），如果成功则返回 true。它通常用在 for 循环的条件里。 Text() string: 返回最近一次 Scan() 扫描到的令牌（行）的字符串内容。 Bytes() []byte: 功能同 Text()，但返回字节切片。 Err() error: 返回扫描过程中遇到的错误。 实战代码：使用 Scanner 按行读取文件（推荐方式） 12345678910111213141516171819202122232425package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)func main() { r := strings.NewReader(&quot;苹果\\n香蕉\\n橘子&quot;) scanner := bufio.NewScanner(r) // for scanner.Scan() 是 Go 中读取文本的惯用写法 (idiom) for scanner.Scan() { line := scanner.Text() // 获取当前行内容 fmt.Printf(&quot;扫描到一行: %s\\n&quot;, line) } // 扫描结束后，检查是否有错误发生 if err := scanner.Err(); err != nil { fmt.Println(&quot;扫描时发生错误:&quot;, err) }} 进阶: scanner.Split() 方法可以让你自定义分割规则，比如按单词、按逗号等。 3. bufio.Writer：高效写入Writer 的核心在于它的缓冲区。数据先写入内存，直到缓冲区满了或你手动“刷新”，才会真正写入底层的文件或网络连接。 创建方式: 1234567import &quot;bufio&quot;import &quot;os&quot;file, _ := os.Create(&quot;output.txt&quot;)defer file.Close()writer := bufio.NewWriter(file) 常用方法: WriteString(s string): 将字符串写入缓冲区。 Write(p []byte): 将字节切片写入缓冲区。 Flush(): 至关重要的方法！ 将缓冲区中所有的数据立刻写入底层的 io.Writer（例如文件）。忘记调用 Flush 是最常见的错误！ 实战代码：使用 Writer 高效写入文件 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() { file, err := os.Create(&quot;output.txt&quot;) if err != nil { panic(err) } defer file.Close() writer := bufio.NewWriter(file) // 写入几行字符串到缓冲区 _, _ = writer.WriteString(&quot;Hello, bufio!\\n&quot;) _, _ = writer.WriteString(&quot;这是第二行。\\n&quot;) fmt.Println(&quot;数据已写入缓冲区，但尚未写入文件。&quot;) // 此时打开 output.txt，你会发现文件是空的！ // 使用 Flush 将缓冲区内容写入文件 err = writer.Flush() if err != nil { panic(err) } fmt.Println(&quot;Flush() 已调用，数据已成功写入文件。&quot;) // 现在打开 output.txt，内容就在里面了。} 最佳实践: 使用 defer 来确保 Flush 总能被执行。 123456789func writeFile() { file, _ := os.Create(&quot;output.txt&quot;) defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() // &lt;--- 使用 defer 确保在函数退出前刷新缓冲区 writer.WriteString(&quot;这样写更安全！\\n&quot;)} 第四阶段：总结与选择 场景 推荐工具 为什么？ 按行/按单词读取文本文件 bufio.Scanner 代码最简洁、性能好、自动处理换行符，是首选。 需要读取到特定字符为止 bufio.Reader ReadString 方法完美匹配此需求。 需要**“偷看”**后面的数据而不移动指针 bufio.Reader 只有 Reader 提供 Peek 功能。 大量、频繁地写入小数据到文件或网络 bufio.Writer 显著提升写入性能，减少系统调用。 读取整个小文件 os.ReadFile 如果文件不大，一次性读入内存更简单，没必要用 bufio。 学习建议: 亲手把上面的每一段代码都敲一遍，并尝试修改它（比如换成真实的文件操作）。 理解 Flush 的重要性，并尝试不调用它看看会发生什么。 练习用 Scanner 读取标准输入 os.Stdin。 问题总结来说，我只需要创建bufio.Reader: 带缓冲区的读取器。bufio.Writer: 带缓冲区的写入器。bufio.Scanner: 一个更高级、更方便的工具，用于读取结构化的文本数据（比如按行、按单词读取）。这三个东西，然后按照需求调用相应的函数就行了是吧 是的，你的总结非常精准！完全正确。 bufio 包的学习和使用核心，就是围绕这三个“主角”展开的。你可以把它们理解为你工具箱里三种不同但相关的工具： bufio.Reader (带缓冲区的读取器) 核心功能: 提供一个缓冲区来加速底层 io.Reader 的读取操作。 何时使用: 当你需要比 Scanner 更底层的控制时，比如： 读取到任意定的分隔符为止 (ReadString)。 需要“偷窥”数据流而不消耗它 (Peek)。 按特定字节数读取 (Read)。 bufio.Writer (带缓冲区的写入器) 核心功能: 提供一个缓冲区来加速底层 io.Writer 的写入操作。 何时使用: 当你需要向文件或网络连接进行大量、零碎的写入时。它能把这些零碎的写入合并成大的块，一次性发送，性能提升巨大。 必须记住: 用完一定要调用 Flush()，否则缓冲区的数据会丢失！最稳妥的方式是 defer writer.Flush()。 bufio.Scanner (高级文本扫描器) 核心功能: 专门用于读取结构化的文本数据。 何时使用: 这是处理文本文件最常用、最推荐的工具。 按行读取文件或标准输入（最常见的场景）。 按单词、逗号或其他自定义规则分割文本。 优点: 接口极其简洁（for scanner.Scan() 循环），性能好，自动处理各种换行符问题，不容易出错。 你的学习和使用流程就是： 明确你的 I/O 需求: “我要读取一个大文本文件，一行一行地处理。” -&gt; 选择 bufio.Scanner。 “我要向一个文件里循环写入上万条日志。” -&gt; 选择 bufio.Writer。 “我要从一个网络连接中读取数据，直到遇到一个特定的字节 0xFF 为止。” -&gt; 选择 bufio.Reader。 创建实例: 找到你的原始 io.Reader（如 os.File, strings.Reader, net.Conn）或 io.Writer。 调用 bufio.NewScanner(reader), bufio.NewReader(reader) 或 bufio.NewWriter(writer) 来“包装”它，得到一个带缓冲区的增强版工具。 调用方法: 根据你的具体需求，调用对应工具的方法（如 scanner.Scan(), reader.ReadString(), writer.WriteString()）。 收尾工作: 如果是 Writer，务必 Flush()。 如果是 Scanner，最好检查一下 scanner.Err()。 记得关闭底层的 io.Closer（如 file.Close()）。 所以，你完全掌握了 bufio 的精髓。剩下的就是在实际编码中多加练习，熟悉这三个工具的常用方法，你就能在 Go I/O 编程中游刃有余了。","link":"/2025/08/25/%E5%88%9D%E5%AD%A6bufio%E5%8C%85/"}],"tags":[],"categories":[],"pages":[]}